{"index":"{\"keys\":[{\"path\":[\"title\"],\"id\":\"title\",\"weight\":1,\"src\":\"title\",\"getFn\":null},{\"path\":[\"body\"],\"id\":\"body\",\"weight\":1,\"src\":\"body\",\"getFn\":null}],\"records\":[{\"i\":0,\"$\":{\"0\":{\"v\":\"Gatsby 시작하기\",\"n\":0.707},\"1\":{\"v\":\"\\r\\n## 특징\\r\\n\\r\\n> React, GraphQL 기반 <u>정적 페이지 (Static Site Generator)</u> 생성  \\r\\n> JAM Stack (Javascript, API, MarkUp Stack) 기반 프레임워크 - 빠르고 안전하고 스케일링 하기 쉬움\\r\\n\\r\\n- 서버와 통신, 동적 생성(Next.js)과 달리 서버 없이 정적 사이트 생성\\r\\n- 빌드 시 각 페이지에 대한 파일 생성, 저장(CDN) 후 요청 시 재사용\\r\\n- CDN(Content Delivery Network) 통해 제공\\r\\n- 기업 소개 페이지, 블로그, 포트폴리오 작업에 적합\\r\\n- 다양한 [플러그인](https://www.gatsbyjs.com/plugins#cms) 사용하여 쉽게 제작 가능\\r\\n\\r\\n## Gatsby 프로젝트 생성\\r\\n\\r\\n```\\r\\nnpx gatsby-cli new \\\"NEW PROJECT\\\"\\r\\n```\\r\\n\\r\\n### Directory\\r\\n- contents: 포스트 관련 파일 (markdown, img)\\r\\n- src\\r\\n\\t- components: React Components\\r\\n\\t- hooks\\r\\n\\t- pages: 파일 명으로 페이지 접근가능\\r\\n\\t- templates: 여러 콘텐츠 Components, Gatsby에서 제공하는 API로 페이지 생성  \\r\\n\\t\\t파일명으로 접근 불가\\r\\n- static: 정적 파일\\r\\n\\r\\n### Gatsby Rendering\\r\\ngatsby-browser.js|gatsby-ssr.js\\r\\n:---|:---\\r\\n브라우저(클라이언트) | 서버\\r\\n페이지 로드 후 | HTML 생성 시\\r\\n전역 CSS Import, 이벤트 제어, 브라우저 전용 API 사용 시 | mata/script/style preload(폰트)\\r\\n\\r\\n- 구글 태그 관리자\\r\\n```js:title=gatsby-ssr.js\\r\\n/**\\r\\n * @type {import('gatsby').GatsbySSR['onRenderBody']}\\r\\n */\\r\\nconst { gtmNoscript, gtmScript } = require('./src/components/Common/gtm-tag')\\r\\n\\r\\nexports.onRenderBody = ({\\r\\n  setHtmlAttributes,\\r\\n  setHeadComponents,\\r\\n  setPreBodyComponents,\\r\\n}) => {\\r\\n  setHtmlAttributes({ lang: `en` })\\r\\n  setHeadComponents([gtmScript])\\r\\n  setPreBodyComponents([gtmNoscript])\\r\\n}\\r\\n```\\r\\n\\r\\n## TypeScript\\r\\n\\r\\n> MicroSoft에서 개발, 오픈 소스 프로그래밍 언어  \\r\\n> Javascript에 타입을 부여한 언어 (Javascript로 컴파일 되어 동작)\\r\\n\\r\\n- 컴파일 단계에서 에러를 알려주어 오류 방지\\r\\n- 변수와 함수의 타입을 알 수 있어 유지보수 용이\\r\\n\\r\\n```\\r\\nyarn add typescript --dev gatsby-plugin-typescript\\r\\n```\\r\\n```js:title=gatsby-config.js\\r\\nmodule.exports = {\\r\\n\\tplugins: [\\r\\n    {\\r\\n      resolve: 'gatsby-plugin-typescript',\\r\\n      options: {\\r\\n        isTSX: true,\\r\\n        allExtensions: true,\\r\\n      },\\r\\n    },\\r\\n    ...\\r\\n  ],\\r\\n}\\r\\n```\\r\\n\\r\\n```\\r\\nyarn tsc --init\\r\\n```\\r\\n```json:title=tsconfig.json\\r\\n{\\r\\n  \\\"compilerOptions\\\": {\\r\\n    \\\"target\\\": \\\"es5\\\",\\r\\n    \\\"module\\\": \\\"commonjs\\\",\\r\\n    \\\"allowJs\\\": true,\\r\\n    \\\"noUnusedLocals\\\": true,\\r\\n    \\\"noUnusedParameters\\\": true,\\r\\n    \\\"noImplicitReturns\\\": true,\\r\\n    \\\"baseUrl\\\": \\\"./src\\\",\\r\\n    \\\"paths\\\": {\\r\\n      \\\"components/*\\\": [\\\"./components/*\\\"],\\r\\n      \\\"utils/*\\\": [\\\"./utils/*\\\"],\\r\\n      \\\"hooks/*\\\": [\\\"./hooks/*\\\"]\\r\\n    },\\r\\n    \\\"strict\\\": true,\\r\\n    \\\"jsx\\\": \\\"preserve\\\",\\r\\n    \\\"jsxImportSource\\\": \\\"@emotion/react\\\",\\r\\n    \\\"esModuleInterop\\\": true,\\r\\n    \\\"skipLibCheck\\\": true,\\r\\n    \\\"forceConsistentCasingInFileNames\\\": true,\\r\\n    \\\"resolveJsonModule\\\": true\\r\\n  },\\r\\n  \\\"include\\\": [\\\"src/**/*.tsx\\\"],\\r\\n  \\\"exclude\\\": [\\\"node_modules\\\"]\\r\\n}\\r\\n```\\r\\n\\r\\n```js:title=gatsby-node.js\\r\\n/**\\r\\n * @type {import('gatsby').GatsbyNode['createPages']}\\r\\n*/\\r\\nconst path = require('path')\\r\\n\\r\\n// Setup Import Alias\\r\\nexports.onCreateWebpackConfig = ({ getConfig, actions }) => {\\r\\n  const output = getConfig().output || {}\\r\\n\\r\\n  actions.setWebpackConfig({\\r\\n    output,\\r\\n    resolve: {\\r\\n      alias: {\\r\\n        components: path.resolve(__dirname, 'src/components'),\\r\\n        utils: path.resolve(__dirname, 'src/utils'),\\r\\n        hooks: path.resolve(__dirname, 'src/hooks'),\\r\\n      },\\r\\n    },\\r\\n  })\\r\\n}\\r\\n```\\r\\n\\r\\n### 함수형 컴포넌트\\r\\n```tsx\\r\\nimport {FunctionComponent} from 'react'\\r\\n\\r\\nconst SomePage: FunctionComponent = function(){\\r\\n\\treturn <Text />\\r\\n}\\r\\nexport default SomePage\\r\\n```\\r\\n\\r\\n### Generic\\r\\n\\r\\n클래스나 함수에서 사용할 타입을 미리 명시 후 사용할 때 결정\\r\\n\\r\\n```tsx\\r\\nimport {FunctionComponent} from 'react'\\r\\n\\r\\ninterface SomeProps {\\r\\n\\ttext: string\\r\\n}\\r\\n\\r\\nconst SomePage: FunctionComponent<SomeProps> = function(){\\r\\n\\treturn <Text />\\r\\n}\\r\\nexport default SomePage\\r\\n```\\r\\n\\r\\n### interface 와 type 차이\\r\\n- `interface`\\r\\n\\t- 객체 타입 정의 시(공개 API) 사용\\r\\n\\t- extends 확장 가능\\r\\n\\r\\n```tsx\\r\\ninterface SomeProps {\\r\\n\\ttitle: string\\r\\n}\\r\\ninterface SomeProps {  // 선언적 확장도 가능\\r\\n\\tbody: string\\r\\n}\\r\\ninterface SomeProps2 extends SomeProps {\\r\\n\\tSomeBody: string\\r\\n}\\r\\nconst MyContents: SomeProps2 = {\\r\\n\\ttitle: '...',\\r\\n\\tbody: '...',\\r\\n\\tSomeBody: '...',\\r\\n}\\r\\n```\\r\\n\\r\\n- `type`\\r\\n\\t- 병합 불가\\r\\n\\t- 확장 시 `&` 연산자 사용\\r\\n\\t- computed value 사용 가능\\r\\n\\r\\n```tsx\\r\\ntype SomeProps{\\r\\n\\ttitle: string\\r\\n} & {\\r\\n\\tbody: string\\r\\n}\\r\\n\\r\\ntype SomeArray = {\\r\\n\\t[key in Somes]: string\\r\\n}\\r\\n```\\r\\n\\r\\n## EmotionJS\\r\\n\\r\\n> styled-components 의 기능과 거의 동일하며 번들 용량이 작다\\r\\n\\r\\n```\\r\\nyarn add gatsby-plugin-emotion @emotion/react @emotion/styled\\r\\n```\\r\\n```js:title=gatsby-config.js\\r\\nmodule.exports = {\\r\\n\\tplugins: [\\r\\n\\t\\t...\\r\\n    `gatsby-plugin-emotion`,\\r\\n    ...\\r\\n  ],\\r\\n}\\r\\n```\\r\\n\\r\\n### Global 스타일 지정 방법\\r\\n```tsx\\r\\nimport { Global, css } from '@emotion/react'\\r\\nconst defaultStyle = css`\\r\\n  body {\\r\\n    margin: 0;\\r\\n    padding: 0;\\r\\n    font-family: Pretendard, system-ui, -apple-system, BlinkMacSystemFont,\\r\\n      'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans',\\r\\n      'Helvetica Neue', sans-serif;\\r\\n    color: #333;\\r\\n  }\\r\\n`\\r\\nconst GlobalStyle: FunctionComponent = function () {\\r\\n  return <Global styles={defaultStyle} />\\r\\n}\\r\\nexport default GlobalStyle\\r\\n```\\r\\n\\r\\n### css 정의 및 적용\\r\\n```tsx\\r\\nimport { css } from '@emotion/react'\\r\\nconst SomeStyle = css`\\r\\n\\tfont-size:14px;\\r\\n`\\r\\n...\\r\\n<div css={SomeStyle}></div>\\r\\n...\\r\\n```\\r\\n\\r\\n### Styled Component 생성 1 : .(dot)을 통해 함수 호출\\r\\nKebab Case\\r\\n```tsx\\r\\nimport { styled } from '@emotion/react'\\r\\nconst SomeStyledComponent = styled.div`\\r\\n\\tfont-size:14px;\\r\\n`\\r\\n<SomeStyledComponent></SomeStyledComponent>\\r\\n```\\r\\n\\r\\n### Styled Component 생성 2 : 객체\\r\\nCamel Case, 스타일 값은 String Type으로 전달\\r\\n```tsx\\r\\nimport { styled } from '@emotion/react'\\r\\nconst SomeComponent = styled('div')(() =>({\\r\\n\\tfontSize: '14px'\\r\\n}))\\r\\n<SomeComponent></SomeComponent>\\r\\n```\\r\\n\\r\\n### Styled Component에서 Props\\r\\n\\r\\n```tsx\\r\\nconst SomeStyledComponent = styled.div<{ disable: boolean }>`\\r\\n\\ttext-decoration: ${({ disable })=>( disable ? `line-through` : `none`)}\\r\\n`\\r\\n```\\r\\n```tsx\\r\\nconst SomeComponent = styled('div')<{ disable: boolean}>(({ disable })=>({\\r\\n\\ttextDecoration: disable ? `line-through` : `none`,\\r\\n}))\\r\\n```\\r\\n```tsx\\r\\nconst Component = styled(({ active, ...props }: Props타입명시) =>(\\r\\n\\t<Link {...props} />\\r\\n)) <Some타입명시>`\\r\\n\\tfont-size: 14px;\\r\\n`\\r\\n```\\r\\n\\r\\n## Gatsby에서 [Markdown](/markdown-syntax) 파일 사용하기\\r\\n\\r\\n### Remark\\r\\n> Markdown을 처리하기 위한 자바스크립트 기반 파서\\r\\n\\r\\n- 변환된 추상 구문 트리(AST, Abstract syntax tree)를 이용하여 다른 플러그인으로 확장\\r\\n- 변환된 AST를 HTML로 변환하여 컴포넌트 출력\\r\\n\\r\\n> [Markdown] &rightarrow; Remark &rightarrow; AST(mdast) &rightarrow; AST 노드에 플러그인 접근(수정, 추가, 삭제) &rightarrow;  \\r\\n> [GraphQL 스키마](#graphql) 생성, 매핑 &rightarrow; [HTML], React 컴포넌트\\r\\n\\r\\n### Markdown 라이브러리\\r\\n- gatsby-source-filesystem  \\r\\n\\t: 변환할 파일 정보 제공 (다른 라이브러리와 연계(~-transformer, ~-images), GraphQL 연결)\\r\\n- gatsby-transformer-remark  \\r\\n\\t: HTML로 변환\\r\\n- gatsby-remark-images     \\r\\n\\t: 이미지 최적화 (반응형, loading lazy)\\r\\n- gatsby-remark-prismjs & prismjs  \\r\\n\\t: code 하이라이팅\\r\\n- gatsby-remark-smartypants  \\r\\n\\t: 문장부호 타이포그래피 가독성 좋게 자동 변환 (ex quotes ' \\\" , ... ---)\\r\\n- gatsby-remark-autolink-headers  \\r\\n\\t: header 바로가기 링크\\r\\n- gatsby-remark-copy-linked-files  \\r\\n\\t: 사용되는 파일 static 경로로 복사 > 빌드 후에도 링크 유효\\r\\n- gatsby-remark-external-links  \\r\\n\\t: 사용되는 링크 태그 속성 지정 (target, rel)\\r\\n- gatsby-omni-font-loader  \\r\\n\\t: web font\\r\\n\\r\\n```\\r\\nyarn add gatsby-transformer-remark gatsby-remark-images gatsby-remark-prismjs prismjs gatsby-remark-smartypants gatsby-remark-copy-linked-files gatsby-remark-external-links\\r\\n```\\r\\n\\r\\n```js:title=gatsby-config.js\\r\\nmodule.exports = {\\r\\n\\t...\\r\\n\\tplugins: [\\r\\n\\t\\t{\\r\\n\\t\\t\\tresolve: `gatsby-plugin-typescript`,\\r\\n\\t\\t\\toptions: {\\r\\n\\t\\t\\t\\tisTSX: true,\\r\\n\\t\\t\\t\\tallExtensions: true,\\r\\n\\t\\t\\t},\\r\\n\\t\\t},\\r\\n\\t\\t`gatsby-plugin-emotion`,\\r\\n\\t\\t{\\r\\n\\t\\t\\tresolve: `gatsby-source-filesystem`,\\r\\n\\t\\t\\toptions: {\\r\\n\\t\\t\\t\\tname: `contents`,\\r\\n\\t\\t\\t\\tpath: `${__dirname}/contents`,\\r\\n\\t\\t\\t},\\r\\n\\t\\t},\\r\\n\\t\\t{\\r\\n\\t\\t\\tresolve: `gatsby-source-filesystem`,\\r\\n\\t\\t\\toptions: {\\r\\n\\t\\t\\t\\tname: `images`,\\r\\n\\t\\t\\t\\tpath: `${__dirname}/static`,\\r\\n\\t\\t\\t},\\r\\n\\t\\t},\\r\\n\\t\\t`gatsby-transformer-sharp`,\\r\\n\\t\\t`gatsby-plugin-sharp`,\\r\\n\\t\\t{\\r\\n\\t\\t\\tresolve: `gatsby-omni-font-loader`,\\r\\n\\t\\t\\toptions: {\\r\\n\\t\\t\\t\\tenableListener: true,\\r\\n\\t\\t\\t\\tpreconnect: [`https://cdn.jsdelivr.net/gh/orioncactus/pretendard`],\\r\\n\\t\\t\\t\\tweb: [\\r\\n\\t\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t\\tname: `Pretendard`,\\r\\n\\t\\t\\t\\t\\t\\tfile: `https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard-dynamic-subset.min.css`,\\r\\n\\t\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\t],\\r\\n\\t\\t\\t},\\r\\n\\t\\t},\\r\\n\\t\\t{\\r\\n\\t\\t\\tresolve: `gatsby-transformer-remark`,\\r\\n\\t\\t\\toptions: {\\r\\n\\t\\t\\t\\tplugins: [\\r\\n\\t\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t\\tresolve: `gatsby-remark-smartypants`,\\r\\n\\t\\t\\t\\t\\t\\toptions: {\\r\\n\\t\\t\\t\\t\\t\\t\\tdashes: `oldschool`,\\r\\n\\t\\t\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t\\tresolve: `gatsby-remark-autolink-headers`,\\r\\n\\t\\t\\t\\t\\t\\toptions: {\\r\\n\\t\\t\\t\\t\\t\\t\\tclassName: `link-headers`,\\r\\n\\t\\t\\t\\t\\t\\t\\telements: [`h2`],\\r\\n\\t\\t\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\t\\t`gatsby-remark-code-titles`,\\r\\n\\t\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t\\tresolve: `gatsby-remark-prismjs`,\\r\\n\\t\\t\\t\\t\\t\\toptions: {\\r\\n\\t\\t\\t\\t\\t\\t\\tclassPrefix: `language-`,\\r\\n\\t\\t\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t\\tresolve: `gatsby-remark-images`,\\r\\n\\t\\t\\t\\t\\t\\toptions: {\\r\\n\\t\\t\\t\\t\\t\\t\\tmaxWidth: 768,\\r\\n\\t\\t\\t\\t\\t\\t\\tquality: 100,\\r\\n\\t\\t\\t\\t\\t\\t\\twithWebp: true,\\r\\n\\t\\t\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t\\tresolve: `gatsby-remark-copy-linked-files`,\\r\\n\\t\\t\\t\\t\\t\\toptions: {},\\r\\n\\t\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t\\tresolve: `gatsby-remark-external-links`,\\r\\n\\t\\t\\t\\t\\t\\toptions: { target: `_blank`, rel: `nofollow` },\\r\\n\\t\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\t],\\r\\n\\t\\t\\t},\\r\\n\\t\\t},\\r\\n\\t\\t...\\r\\n\\t],\\r\\n}\\r\\n```\\r\\n\\r\\ncode 테마 적용\\r\\n```js:title=gatsby-browser.js\\r\\nimport 'prismjs/themes/prism-tomorrow.css';\\r\\n```\\r\\n\\r\\n## GraphQL\\r\\n\\r\\n> 페이스북 쿼리언어  \\r\\n> 클라이언트가 요청한 데이터(필요한 데이터)만 가져온다\\r\\n\\r\\n### Gatsby에서 GraphQL 사용하기\\r\\n\\r\\n#### GraphiQL (IDE)\\r\\n```\\r\\nView GraphiQL, an in-browser IDE, to explore your site's data and schema\\r\\n\\r\\n\\thttp://localhost:8000/___graphql \\r\\n```\\r\\n\\r\\n- 홈페이지의 메타데이터, 마크다운 데이터, 이미지 데이터를 Query하여 얻을 수 있다.\\r\\n- 직접 생성한 페이지(src/pages/) 또는 Gatsby가 제공한 페이지(Node API `createPages`)에서 Query 정의 가능하다.\\r\\n\\r\\n> GraphQL 스키마(Query 정의) &rightarrow; Query export(질의) &rightarrow; Gatsby 요청/응답 &rightarrow; 데이터를 Props(키 값 data)로 전달\\r\\n\\r\\n- GraphQL 스키마 (데이터 구성 방식) : 데이터 사용 전 타입 정의\\r\\n\\r\\n```tsx\\r\\nimport { graphql } from 'gatsby'\\r\\ntype SomeContentProps = {  // GraphQL 스키마 정의\\r\\n\\tdata: {\\r\\n\\t\\tsomeQuery:{\\r\\n\\t\\t\\tsome: string\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\nconst SomeContent: FunctionComponent<SomeContentProps> = function({\\r\\n\\t// 데이터 (결과)\\r\\n\\tdata: {\\r\\n\\t\\tsomeQuery: {\\r\\n\\t\\t\\tsome\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}) {\\r\\n\\treturn(\\r\\n\\t\\t<div> {some} </div>\\r\\n\\t)\\r\\n}\\r\\nexport default SomeContent\\r\\n\\r\\nexport const someQuery = graphql`  // Query export(질의)\\r\\n\\tquery someQuery { // 디버깅 시 로그에서 쿼리 이름(someQuery) 확인 가능\\r\\n\\t\\t{\\r\\n\\t\\t\\tsome{}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n`\\r\\n```\\r\\n\\r\\n### Markdown 파일에서 GraphQL (gatsby-transformer-remark 라이브러리)\\r\\n- MarkdownRemark : 파일 1개\\r\\n- allMarkdownRemark : 파일 여러개\\r\\n- file : 이미지, 파일\\r\\n- edges : 연결 (배열)\\r\\n- node : 개별 실제 데이터\\r\\n- frontmatter : 상단 메타데이터\\r\\n\\r\\n```tsx\\r\\nimport { graphql } from 'gatsby'\\r\\ntype SomePageProps = {\\r\\n\\tdata:{\\r\\n\\t\\tallMarkdownRemark:{\\r\\n\\t\\t\\tedges: {node:{id...}}\\r\\n\\t\\t}\\r\\n\\t\\tfile:{\\r\\n\\t\\t\\tchildrenImagesharp: string\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\nconst SomePage: FunctionComponent<SomePageProps> = function({\\r\\n\\tdata: {\\r\\n\\t\\tallMarkdownRemark: {edges},\\r\\n\\t\\tfile:{\\r\\n\\t\\t\\tchildrenImageSharp: {gatsbyImageData},\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}) {\\r\\n\\r\\n\\treturn (<div />)\\r\\n}\\r\\nexport default SomePage\\r\\n\\r\\nexport const SomeQuery = graphql`\\r\\n\\tquery SomeQuery {\\r\\n\\t\\tallMarkdownRemark(sort){\\r\\n\\t\\t\\tedges{\\r\\n\\t\\t\\t\\tnode{\\r\\n\\t\\t\\t\\t\\tid\\r\\n\\t\\t\\t\\t\\tfrontmatter{ title summary....}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tfile(name: {} ){\\r\\n\\t\\t\\tchildImageSharp{\\r\\n\\t\\t\\t\\tgatsbyImageData(width:..., height:,,,)\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n`\\r\\n```\\r\\n\\r\\n## Gatsby Link API\\r\\n- 경로를 to(props)로 전달\\r\\n- 페이지의 Link 모두 찾은 후 모든 페이지(to=\\\"경로\\\") Prefetch > 로딩 속도 빠름\\r\\n\\r\\n* * *\\r\\n- React 기반 Gatsby로 기술 블로그 개발하기\\r\\n\\r\\n  <https://www.inflearn.com/course/gatsby-기술블로그/dashboard>\",\"n\":0.033}}},{\"i\":1,\"$\":{\"0\":{\"v\":\"Gatsby 페이지 구현하기\",\"n\":0.577},\"1\":{\"v\":\"\\r\\n## query-string\\r\\n> URL의 Query String(search parameters) 객체로 변환\\r\\n\\r\\n- URL Query String : 엔드포인트 주소 이후 ?parameter=value\\r\\n- 여러개일 경우 `&` : \\\\~/?key=value&key=value\\r\\n```tsx\\r\\nimport queryString, { ParsedQuery } from 'query-string'\\r\\n\\r\\nconst somePage: FunctionComponent<~Props> = function(){\\r\\n\\tconst parsed: ParsedQuery<string> = queryString.parse(location.search)\\r\\n\\tconst selected: string =\\r\\n\\t\\ttypeof parsed.someCategory !== 'string' || !parsed.someCategory\\r\\n\\t\\t\\t? 'All' \\r\\n\\t\\t\\t: parsed.someCategory\\r\\n\\r\\n\\treturn <div />\\r\\n}\\r\\n```\\r\\n- location.search : [Gatsby page 컴포넌트]의 기본 props(ex location.pathname, location.hash...)\\r\\n\\r\\n## List Paint\\r\\n> `Array.prototype.reduce()`, `Array.prototype.filter()` 메서드 사용\\r\\n```javascript\\r\\narray.reduce((accumulator, current)=>{\\r\\n\\t...\\r\\n\\treturn accumulator;\\r\\n}, {initialValue})\\r\\n```\\r\\n```javascript\\r\\narray.filter((sort) => result)\\r\\n// array 반환\\r\\n// true : 배열에 요소 유지 | false : 배열에 요소 제거\\r\\n```\\r\\n\\r\\n```tsx\\r\\nconst somePage: FunctionComponent<~Props> = function(){\\r\\n\\tconst listTabs = useMemo(()=>\\r\\n\\t\\tdata.reduce((list, {node:{ frontmatter: { querys }}}) =>{\\r\\n\\t\\t\\tquerys.forEach((query)=>{\\r\\n\\t\\t\\t\\tquery in list ? list[query]++ : (list[query] = 1)\\r\\n\\t\\t\\t})\\r\\n\\t\\t\\tlist['All']++\\r\\n\\t\\t\\treturn list\\r\\n\\t\\t},{ All: 0 })\\r\\n\\t,[])\\r\\n\\r\\n\\tconst data = useMemo(() => (\\r\\n\\t\\t\\titems.filter({node:{someCategory}}) =>\\r\\n\\t\\t\\t\\tselected === 'All' ? true : someCategory.includes(selected)\\r\\n\\r\\n\\t\\t), [selected]\\r\\n\\t)\\r\\n\\r\\n\\treturn (\\r\\n\\t\\t<Template>\\r\\n\\t\\t\\t<Tabs listTabs={listTabs} />\\r\\n\\t\\t\\t<ListWrapper ref={}> // Infinity Scroll\\r\\n\\t\\t\\t\\t{data.map(\\r\\n\\t\\t\\t\\t\\t({node:{props, slug}}) => <Item {...props} link={slug} />\\r\\n\\t\\t\\t\\t)}\\r\\n\\t\\t\\t</ListWrapper>\\r\\n\\t\\t</Template>\\r\\n\\t)\\r\\n}\\r\\n```\\r\\n\\r\\n## Infinity Scroll\\r\\n- List와 hook 참조 시킨 후 원하는 갯수 만큼 props의 데이터 잘라내 반환  \\r\\n\\tList: `<ListWrapper ref={containerRef}>`  \\r\\n\\t원하는 갯수: `const [count, setCount] = useState<number>(1)`\\r\\n\\r\\n```tsx:title=List.tsx\\r\\nconst List: FunctionComponent<ListProps> =({ propsData }) =>{\\r\\n\\tconst { containerRef, itemsList } = hook( propsData )\\r\\n\\treturn(\\r\\n\\t\\t<ListWrapper ref={containerRef}>\\r\\n\\t\\t\\t{itemsList.map(\\r\\n\\t\\t\\t\\t({node:{props, slug}}) => (\\r\\n\\t\\t\\t\\t\\t<Item {...props} link={slug} />\\r\\n\\t\\t\\t\\t)\\r\\n\\t\\t\\t)}\\r\\n\\t\\t</ListWrapper>\\r\\n\\t)\\r\\n}\\r\\n```\\r\\n\\r\\n```tsx:title=hook.tsx\\r\\nconst hook = ({ propsData }) => {\\r\\n\\tconst containerRef = MutableRefObject<HTMLDivElement | null> = useRef<HTMLDivElement>(null)\\r\\n\\tconst observer: MutableRefObject<IntersectionObserver | null> = useRef<IntersectionObserver>(null)\\r\\n\\tconst [count, setCount] = useState<number>(1)\\r\\n\\r\\n\\tconst itemsData = [...propsData] // propsData 필터 하기(propsData.filter((selected) => true array)\\r\\n\\r\\n\\tuseEffect(()=>{\\r\\n\\t\\tobserver.current = new IntersectionObserver((entries, observer) =>{\\r\\n\\t\\t\\t\\tif (!entries[0].isIntersecting) return\\r\\n\\t\\t\\t\\tsetCount(val => val + 1)\\r\\n\\t\\t\\t\\tobserver.unobserve(entries[0].target)\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\t{ threshold:1 },\\r\\n\\t\\t)\\r\\n\\t}, [])\\r\\n\\r\\n\\tuseEffect(() =>{\\r\\n\\t\\tif(데이터 없을 시, 데이터 적을 시 ||\\r\\n\\t\\t\\tcontainerRef.current === null ||\\r\\n\\t\\t\\tcontainerRef.current.children.length === 0\\r\\n\\t\\t)\\r\\n\\t\\t\\treturn\\r\\n\\t\\t\\r\\n\\t\\t// 감지 할 object : 제일 마지막 children\\r\\n\\t\\tobserver.current.observe(\\r\\n\\t\\t\\tcontainerRef.current.children[containerRef.current.children.length - 1]\\r\\n\\t\\t)\\r\\n\\t}, [count])\\r\\n\\r\\n\\treturn{\\r\\n\\t\\tcontainerRef,\\r\\n\\t\\titemsList: itemsData.slice(0, count);\\r\\n\\t}\\r\\n}\\r\\n```\\r\\n\\r\\n## onCreateNode (Gatsby API)\\r\\n> MarkdownRemark 데이터에 Slug 필드 생성하기\\r\\n\\r\\n### Slug\\r\\n- 특정 페이지의 제목을 핵심 키워드 조합으로 식별하기 위해 만드는 방법\\r\\n- URL 경로에 사용 (SEO 친화적)\\r\\n\\r\\n- [gatsby-source-filesystem](/gatsby-starter/#gatsby에서-markdown-파일-사용하기) 라이브러리를 통해 root(`${__dirname}`)/contents/ 내의 모든 마크다운 파일들마다 파일위치,파일 명으로 Slug 생성\\r\\n```js:title=gatsby-node.js\\r\\nconst path = require('path')\\r\\nconst { createFilePath } = require(`gatsby-source-filesystem`)\\r\\n\\r\\nexports.onCreateNode = ({ node, getNode, actions }) => {\\r\\n\\tconst { createNodeField } = actions\\r\\n\\tif (node.internal.type === `MarkdownRemark`) {\\r\\n\\t\\tconst slug = createFilePath({ node, getNode })\\r\\n\\t\\tcreateNodeField({ node, name: 'slug', value: slug })\\r\\n\\t}\\r\\n}\\r\\n```\\r\\n\\r\\n## createPages (Gatsby API)\\r\\n> 생성한 Slug로 페이지 생성하기\\r\\n\\r\\n1. 마크다운 데이터의 모든 slug 조회 (graphql), 날짜 제목 내림차순(sort)\\r\\n2. 조회 한 slug의 데이터 생성(queryAllMarkdownData), 없을 시 에러 (reporter.panicOnBuild: 개발 시 서버 실행, 빌드 시 중단)\\r\\n3. 생성 한 데이터(queryAllMarkdownData)를 통해 페이지 생성  \\r\\n\\t`queryAllMarkdownData.forEach(({node:{ fields: { slug } }}) => ...createPage(pageOptions))` : `generatePage`\\r\\n4. `createPage`의 옵션 (객체 형식)\\r\\n\\t- path - slug 데이터 그대로 사용(url)\\r\\n\\t- component - path 라이브러리를 통해 불러온 템플릿\\r\\n\\t- context: { slug } - 이 데이터(slug 객체)는 템플릿 컴포넌트(`src/templates/some_template.tsx`)에서 **Props**로 받을 수 있으며 **GraphQL Query 파라미터**로 받을 수 있다.\\r\\n\\r\\n```tsx:title=src/templates/some_template.tsx\\r\\nimport React, { FunctionComponent } from 'react'\\r\\n\\r\\nconst someTemplate: FunctionComponent<~Props> = function (props) {\\r\\n  console.log(props)\\r\\n\\r\\n  return <div></div>\\r\\n}\\r\\n\\r\\nexport default someTemplate\\r\\n```\\r\\n```js:title=gatsby-node.js\\r\\nconst path = require('path')\\r\\n\\r\\nexports.createPages = async ({ actions, graphql, reporter }) => {\\r\\n\\tconst { createPage } = actions\\r\\n\\r\\n\\tconst queryAllMarkdownData = await graphql(\\r\\n\\t\\t`\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tallMarkdownRemark(\\r\\n\\t\\t\\t\\t\\tsort: {\\r\\n\\t\\t\\t\\t\\t\\torder: DESC\\r\\n\\t\\t\\t\\t\\t\\tfields: [frontmatter___date, frontmatter___title]\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t) {\\r\\n\\t\\t\\t\\t\\tedges {\\r\\n\\t\\t\\t\\t\\t\\tnode {\\r\\n\\t\\t\\t\\t\\t\\t\\tfields {\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tslug\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t`,\\r\\n\\t)\\r\\n\\r\\n\\t// Handling GraphQL Query Error\\r\\n\\tif (queryAllMarkdownData.errors) {\\r\\n\\t\\treporter.panicOnBuild(`Error While running query`)\\r\\n\\t\\treturn\\r\\n\\t}\\r\\n\\r\\n\\t// Import Post Template Component\\r\\n\\tconst PostTemplateComponent = path.resolve(\\r\\n\\t\\t__dirname,\\r\\n\\t\\t`src/templates/some_template.tsx`,\\r\\n\\t)\\r\\n\\r\\n\\t// Page Generating Function\\r\\n\\tconst generatePage = ({\\r\\n\\t\\tnode: {\\r\\n\\t\\t\\tfields: { slug },\\r\\n\\t\\t},\\r\\n\\t}) => {\\r\\n\\t\\tconst pageOptions = {\\r\\n\\t\\t\\tpath: slug,\\r\\n\\t\\t\\tcomponent: PostTemplateComponent,\\r\\n\\t\\t\\tcontext: { slug },\\r\\n\\t\\t}\\r\\n\\t\\tcreatePage(pageOptions)\\r\\n\\t}\\r\\n\\t// Generate Post Page And Passing Slug Props for Query\\r\\n\\tqueryAllMarkdownData.data.allMarkdownRemark.edges.forEach(generatePage)\\r\\n}\\r\\n```\\r\\n\\r\\n## 템플릿 컴포넌트 데이터 조회하기\\r\\n### GraphQL Query 파라미터 Template에서 받기\\r\\n- query내에서 파라미터 사용 시 필드와 구분하기 위해 `$` 접두사 붙인 후 타입 명시(타입 명 - 대문자 시작)\\r\\n- context 데이터 객체 내의 Props와 동일한 key 값으로 설정\\r\\n- `eq:`(equal) property로 slug와 일치하는 마크다운 데이터만 query\\r\\n```tsx:title=src/templates/some_template.tsx\\r\\n...\\r\\nquery queryMarkdownDataBySlug($slug: String){\\r\\n\\tallMarkdownRemark(filter: { fields: { slug: { eq: $slug } } }) {edges{node...}}\\r\\n}\\r\\n```\\r\\n\\r\\n## Markdown 문서 HTML 출력\\r\\n> __html key에 HTML 태그로 변환되어 문자열로 저장 (frontmatter 제외)\\r\\n```tsx\\r\\ninterface ContentProps{\\r\\n\\thtml: string\\r\\n}\\r\\nconst Content: FunctionComponent<ContentProps> = ({html}) =>{\\r\\n\\treturn <Some dangerouslySetInnerHTML={{_html: html}}>\\r\\n}\\r\\n```\\r\\n\\r\\n## Meta Tag\\r\\n\\r\\n### React-Helmet\\r\\n```\\r\\nyarn add @types/react-helmet\\r\\n```\\r\\n- 중복된 경우 나중에 정의된 태그 적용\\r\\n```tsx\\r\\nimport { Helmet } from 'react-helmet'\\r\\n\\r\\nconst Template: FunctionComponent<TemplateProps> = function({\\r\\n\\ttitle,\\r\\n\\tdescriptions,\\r\\n\\turl,\\r\\n\\t...\\r\\n}){\\r\\n\\treturn(\\r\\n\\t\\t<Wrapper>\\r\\n\\t\\t\\t<Helmet>\\r\\n\\t\\t\\t\\t<title>WebSite</title>\\r\\n\\t\\t\\t\\t<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" />\\r\\n        <meta httpEquiv=\\\"Content-Type\\\" content=\\\"text/html;charset=UTF-8\\\" />\\r\\n\\r\\n\\t\\t\\t\\t<meta property=\\\"og:title\\\" content={title} />\\r\\n\\t\\t\\t\\t<meta property=\\\"og:description\\\" content={description} />\\r\\n\\t\\t\\t\\t<meta property=\\\"og:image\\\" content={image} />\\r\\n\\t\\t\\t\\t<meta property=\\\"og:url\\\" content={url} />\\r\\n\\t\\t\\t\\t<meta property=\\\"og:site_name\\\" content={title} />\\t\\t\\t\\t\\r\\n\\t\\t\\t</Helmet>\\r\\n\\t\\t\\t...\\r\\n\\t\\t</Wrapper>\\r\\n\\t)\\r\\n}\\r\\n```\\r\\n### GraphQL로 각 페이지 Helmet에 데이터 전달\\r\\n\\r\\n```js:title=gatsby-config.js\\r\\nmodule.exports = {\\r\\n  siteMetadata: {\\r\\n    title: `Gatsby Test Site`,\\r\\n    description: `블로그 입니다.`,\\r\\n    author: `@Mee`,\\r\\n    siteUrl: `~/test-gatsby/`,\\r\\n  },\\r\\n}\\r\\n```\\r\\n\\r\\n#### Main\\r\\n```tsx:title=index.tsx\\r\\ntype IndexProps = {\\r\\n\\t...\\r\\n\\tdata: {\\r\\n\\t\\tsite: {\\r\\n\\t\\t\\tshiteMetadata: {\\r\\n\\t\\t\\t\\ttitle: string\\r\\n\\t\\t\\t\\tdescription: string\\r\\n\\t\\t\\t\\tsiteUrl: string\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t...\\r\\n\\tfile: {\\r\\n\\t\\tpublicURL: string\\r\\n\\t}\\r\\n}\\r\\n\\r\\nconst Index: FunctionComponent<IndexProps> = function({\\r\\n\\tdata: {\\r\\n\\t\\tsite: {\\r\\n\\t\\t\\tsiteMetadata: {title, description, siteUrl}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}) {\\r\\n\\treturn (\\r\\n\\t\\t<Template\\r\\n\\t\\t\\ttitle={title}\\r\\n      description={description}\\r\\n      url={siteUrl}\\r\\n      image={publicURL}\\r\\n\\t\\t/>\\r\\n\\t)\\r\\n}\\r\\n\\r\\nexport const getIndex = graphql`\\r\\n\\tquery getIndex {\\r\\n\\t\\tsite{\\r\\n\\t\\t\\tsiteMetadata{\\r\\n\\t\\t\\t\\ttitle\\r\\n\\t\\t\\t\\tdescription\\r\\n\\t\\t\\t\\tsiteUrl\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n`\\r\\n```\\r\\n- publicURL(static 경로) : 원본 파일 그대로 가져올 때 사용\\r\\n\\r\\n#### Sub\\r\\n```tsx:title=template.tsx\\r\\ntype TemplateProps = {\\r\\n\\t...\\r\\n\\tlocation: {\\r\\n\\t\\thref: string\\r\\n\\t}\\r\\n}\\r\\n\\r\\nconst Template: FunctionComponent<TemplateProps> = function({\\r\\n\\t...\\r\\n\\tlocation: { href },\\r\\n}) {\\r\\n\\r\\n\\treturn (\\r\\n\\t\\t<Template\\r\\n\\t\\t\\ttitle={title}\\r\\n      description={summary}\\r\\n      url={href}\\r\\n      image={publicURL}\\r\\n\\t\\t/>\\r\\n\\t)\\r\\n}\\r\\n\\r\\nexport const queryMarkdown = graphql`\\r\\n\\tquery queryMarkdown($slug: String) {\\r\\n\\t\\tallMarkdownRemark(sort){\\r\\n\\t\\t\\tedges {\\r\\n\\t\\t\\t\\tnode{ ... }\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n`\\r\\n```\\r\\n\\r\\n## Canonical Link\\r\\n> 중복된 페이지 중 표준으로 사용되는 URL이 무엇인지 검색 엔진에 알려주는 메타 태그\\r\\n\\r\\n- 검색 엔진 임의로 표준 지정 방지\\r\\n- 중복 콘텐츠로 SEO 분산 방지\\r\\n- 크롤링 효율성 향상\\r\\n\\r\\n### 중복된 페이지 발생 이유\\r\\n- 디바이스 별 구분된 웹사이트(적응형)\\r\\n- url 쿼리 스트링 사용\\r\\n\\r\\n```html\\r\\n<head>\\r\\n\\t<link rel=\\\"canonical\\\" href=\\\"https://www.~.com\\\" />\\r\\n</head>\\r\\n```\\r\\n- 절대경로로 작성\\r\\n- 태그 중첩하지 않도록 작성\\r\\n\\r\\n### Gatsby Canonical 라이브러리\\r\\n```\\r\\nyarn add gatsby-plugin-canonical-urls\\r\\n```\\r\\n```js:title=gatsby-config.js\\r\\nmodule.exports = {\\r\\n\\tplugins: [\\r\\n\\t\\t{\\r\\n\\t\\t\\tresolve: `gatsby-plugin-canonical-urls`,\\r\\n\\t\\t\\toptions: {\\r\\n\\t\\t\\t\\tsiteUrl: `https://www.~.com`,\\r\\n\\t\\t\\t\\tstripQueryString: true,\\r\\n\\t\\t\\t},\\r\\n\\t\\t},\\r\\n\\t],\\r\\n};\\r\\n```\\r\\n- stripQueryString : 쿼리 스트링 제거 옵션\\r\\n\\r\\n## Sitemap\\r\\n```\\r\\nyarn add gatsby-plugin-sitemap\\r\\n```\\r\\n```js:title=gatsby-config.js\\r\\nmodule.exports = {\\r\\n\\tplugins: [\\r\\n\\t\\t'gatsby-plugin-sitemap',\\r\\n\\t],\\r\\n};\\r\\n```\\r\\n- sitemap-0.xml, sitemap-1.xml (특정 갯수 이상 일 경우 sitemap 인식 못하는 문제 해결)\\r\\n\\r\\n## robots.txt\\r\\n```\\r\\nyarn add gatsby-plugin-robots-txt\\r\\n```\\r\\n```js:title=gatsby-config.js\\r\\nmodule.exports = {\\r\\n\\tplugins: [\\r\\n\\t\\t{\\r\\n\\t\\t\\tresolve: 'gatsby-plugin-robots-txt',\\r\\n\\t\\t\\toptions: {\\r\\n\\t\\t\\t\\tpolicy: [{ userAgent: '*', allow: '/' }],\\r\\n\\t\\t\\t},\\r\\n\\t\\t},\\r\\n\\t],\\r\\n};\\r\\n```\\r\\n\\r\\n* * *\\r\\n- React 기반 Gatsby로 기술 블로그 개발하기  \\r\\n  <https://www.inflearn.com/course/gatsby-기술블로그/dashboard>\\r\\n\\r\\n- [표준 URL을 지정 하는 방법](https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls?hl=ko&visit_id=638652447901198736-2506116594&rd=1#rel-canonical-link-method)\",\"n\":0.035}}},{\"i\":2,\"$\":{\"0\":{\"v\":\"Lottie\",\"n\":1},\"1\":{\"v\":\"\\r\\n> 에어비엔비에서 개발한 JSON 기반 애니메이션 오픈 소스 라이브러리  \\r\\n- Adobe After Effects 애니메이션을 JSON 기반 데이터로 추출\\r\\n- 벡터 기반\\r\\n\\r\\n### [Lottie Player](https://github.com/LottieFiles/lottie-player)\\r\\n```html\\r\\n<script src=\\\"https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js\\\"></script>\\r\\n<lottie-player src=\\\"ex.json\\\"></lottie-player>\\r\\n```\\r\\n\\r\\n### [dotLottie](https://github.com/LottieFiles/dotlottie-web) (.lottie)\\r\\n> Lottie.json의 새로운 압축 포맷\\r\\n```html\\r\\n<script src=\\\"https://unpkg.com/@dotlottie/player-component@2.7.12/dist/dotlottie-player.mjs\\\" type=\\\"module\\\"></script>\\r\\n<dotlottie-player src=\\\"ex.json / ex.lottie\\\"></dotlottie-player>\\r\\n```\\r\\n- 파일끼리 아카이빙 가능\\r\\n\\r\\n## [Lottie Interactivity](https://lottiefiles.com/interactivity)\\r\\n> Event 라이브러리\\r\\n```html\\r\\n<script src=\\\"https://unpkg.com/@lottiefiles/lottie-interactivity@latest/dist/lottie-interactivity.min.js\\\"></script>\\r\\n```\\r\\n\",\"n\":0.152}}},{\"i\":3,\"$\":{\"0\":{\"v\":\"Markdown syntax\",\"n\":0.707},\"1\":{\"v\":\"\\r\\n## Markdown\\r\\n\\r\\n> 복잡한 MarkUp 태그 문법을 글 작성에 집중할 수 있도록 경량화한 언어  \\r\\n> Markdown syntax 는 HTML 태그로 변환되어 출력\\r\\n\\r\\n### 장점\\r\\n\\r\\n- 문법이 쉽다.\\r\\n- 읽고, 쓰고, 편집하기 쉽다.\\r\\n- 지원 가능 플랫폼과 프로그램이 다양하기 때문에 호환성이 높다.\\r\\n- 플랫폼 이동 시 작성한 문서를 다시 옮길 작업이 필요없다.\\r\\n\\r\\n### 단점\\r\\n\\r\\n- 표준이 없어 사용자마다 문법이 다르다.\\r\\n- 모든 HTML 마크업을 대체하지 못한다.\\r\\n\\r\\n## 제목\\r\\n\\r\\n> 1~6개의 `#` 추가\\r\\n\\r\\n```markdown\\r\\n# h1 \\r\\n## h2\\r\\n### h3\\r\\n#### h4\\r\\n##### h5\\r\\n###### h6\\r\\n```\\r\\n\\r\\n`<h1>` 태그는 문서당 하나만 사용\\r\\n\\r\\n## 텍스트 스타일\\r\\n\\r\\n> 마크다운에서 지원하지 않는 태그 직접 사용가능 (`<ins>` `<u>`)\\r\\n\\r\\n스타일|구문|출력\\r\\n:---|:---|:---\\r\\n이탤릭체 | `*기울임*` `_기울임_ ` | *기울임*\\r\\n볼드 | `**굵게**` `__굵게__ ` | **굵게**\\r\\n이탤릭체 볼드 | `***기울임 굵게***` | ***기울임 굵게***\\r\\n취소선 | `~취소선~` `~~취소선~~` | ~취소선~\\r\\n언더라인 | `<ins>밑줄</ins>` `<u>밑줄</u>` | <ins>밑줄</ins>\\r\\n\\r\\n## 목록\\r\\n\\r\\n> `<ol>` `<ul>` `<li>` 태그로 변환  \\r\\n> 들여쓰기(tab)로 하위 목록 작성 가능\\r\\n\\r\\n- 순서 있는 목록 `<ol>`: 숫자 기입, 순서대로 숫자를 매긴다.\\r\\n- 순서 없는 목록 `<ul>`: `-` `*` `+` 기입\\r\\n\\r\\n```markdown\\r\\n1. 순서1\\r\\n1. 순서2\\r\\n1. 순서3\\r\\n\\t1. 순서 3-1\\r\\n\\t1. 순서 3-2\\r\\n\\t1. 순서 3-3\\r\\n\\r\\n- 순서가 없는 항목\\r\\n- 순서가 없는 항목\\r\\n\\t- 순서가 없는 항목\\r\\n\\t- 순서가 없는 항목\\r\\n\\t\\t- 순서가 없는 항목\\r\\n\\t\\t* 순서가 없는 항목\\r\\n\\t\\t+ 순서가 없는 항목\\r\\n```\\r\\n\\r\\n1. 순서1\\r\\n1. 순서2\\r\\n1. 순서3\\r\\n\\t1. 순서 3-1\\r\\n\\t1. 순서 3-2\\r\\n\\t1. 순서 3-3\\r\\n\\r\\n- 순서가 없는 항목\\r\\n- 순서가 없는 항목\\r\\n\\t- 순서가 없는 항목\\r\\n\\t- 순서가 없는 항목\\r\\n\\t\\t- 순서가 없는 항목\\r\\n\\t\\t* 순서가 없는 항목\\r\\n\\t\\t+ 순서가 없는 항목\\r\\n\\r\\n### 작업 목록\\r\\n\\r\\n> 목록 항목 앞에 하이픈 `-` + 공백 + `[ ]` or `[x]` (공백 유의)\\r\\n\\r\\n```markdown\\r\\n- [ ] 작업중\\r\\n- [x] 작업완료\\r\\n```\\r\\n- [ ] 작업중\\r\\n- [x] 작업완료\\r\\n\\r\\n## 텍스트 인용\\r\\n\\r\\n> `>` 사용하여 텍스트 인용\\r\\n\\r\\n```markdown\\r\\n> 여러줄도 <br>\\r\\n> 가능\\r\\n```\\r\\n\\r\\n> 여러줄도 <br>\\r\\n> 가능\\r\\n\\r\\n## Code 블록\\r\\n\\r\\n> `<code>` 태그로 변환하여 코드 표현\\r\\n\\r\\n### 1. 인라인\\r\\n\\r\\n- `<code>` 태그로 변환\\r\\n- 백틱 \\\\` 으로 감싼다.\\r\\n\\r\\n```markdown\\r\\n`인라인 코드`\\r\\n```\\r\\n`인라인 코드`\\r\\n\\r\\n### 2. 블록\\r\\n\\r\\n- `<pre>` + `<code>` 태그로 변환\\r\\n- 백틱 3개 이상 사용하여 블록 안으로 코드 또는 텍스트 서식 지정  \\r\\n- 백틱의 시작과 종료 갯수가 같아야 한다. (아래 예시는 백틱 3개)\\r\\n\\r\\n````markdown\\r\\n```css\\r\\n.someClass {\\r\\n  color:#000;\\r\\n}\\r\\n```\\r\\n````\\r\\n\\r\\n```css\\r\\n.someClass {\\r\\n  color:#000;\\r\\n}\\r\\n```\\r\\n\\r\\n` ```html `\\r\\n```html\\r\\n<div> Some </div>\\r\\n```\\r\\n\\r\\n` ```javascript `\\r\\n```Javascript\\r\\nfunction some (){}\\r\\n```\\r\\n\\r\\n### 3. 타이틀\\r\\n````markdown\\r\\n```tsx:title=Title.tsx\\r\\n<Some />\\r\\n```\\r\\n````\\r\\n```tsx:title=Title.tsx\\r\\n<Some />\\r\\n```\\r\\n\\r\\n## 테이블\\r\\n\\r\\n- 3개 이상의 `-`(hyphen) 사용하여 헤더 구분  \\r\\n- `:` (colons) 위치로 align  \\r\\n- 가장 좌측, 우측 `|` 생략 가능 (플랫폼에 따라 불가한 경우도 있음)\\r\\n\\r\\n```markdown\\r\\n|th|th|th|\\r\\n|:---|:---|:---|\\r\\n|td|td|td|\\r\\n|td|td|td|\\r\\n\\r\\nth|th|th\\r\\n:---|:---:|---:\\r\\n좌측정렬|가운데정렬|우측정렬\\r\\ntd|td|td\\r\\n\\r\\n```\\r\\nth|th|th\\r\\n---|---|---\\r\\ntd|td|td\\r\\ntd|td|td\\r\\n\\r\\nth|th|th\\r\\n:---|:---:|---:\\r\\n좌측정렬|가운데정렬|우측정렬\\r\\ntd|td|td\\r\\n\\r\\n## 줄바꿈\\r\\n\\r\\n> 마지막 문장에서 띄어쓰기 2번 이상 입력 또는 `<br>`\\r\\n\\r\\n```markdown\\r\\n줄바꿈  \\r\\n입니다\\r\\n```\\r\\n줄바꿈  \\r\\n입니다\\r\\n\\r\\n## 링크\\r\\n\\r\\n> `<a>` 변환\\r\\n\\r\\n```markdown\\r\\n1. 외부 링크\\r\\n[Link Text](Link \\\"title\\\")\\r\\n2. 외부 링크 그대로 사용\\r\\nLink\\r\\n3. 내부 링크\\r\\n[Link Text](#header-title)\\r\\n\\r\\n1. [NAVER](https://www.naver.com \\\"네이버로 이동합니다.\\\")\\r\\n2. https://www.naver.com\\r\\n3. [링크](#링크)\\r\\n```\\r\\n1. [NAVER](https://www.naver.com \\\"네이버로 이동합니다.\\\")\\r\\n2. https://www.naver.com\\r\\n3. [링크](#링크)\\r\\n\\r\\n## 이미지\\r\\n\\r\\n> `<img>` 변환\\r\\n\\r\\n```markdown\\r\\n![alt](이미지 주소 \\\"title\\\")\\r\\n\\r\\n1. 이미지  \\r\\n![바다사진](./img1.jpg \\\"바다\\\")\\r\\n2. 이미지 링크  \\r\\n[![바다사진](./img1.jpg \\\"바다\\\")](https://www.naver.com)\\r\\n```\\r\\n### 1. 이미지  \\r\\n![바다사진](./img1.jpg \\\"바다\\\")\\r\\n### 2. 이미지 링크  \\r\\n[![바다사진](./img1.jpg \\\"바다\\\")](https://www.naver.com)\\r\\n\\r\\n## Horizontal Rule\\r\\n\\r\\n> 각 기호를 3개 이상 입력 또는 `<hr>`\\r\\n\\r\\n```markdown\\r\\n***\\r\\n* * *\\r\\n---\\r\\n- - -\\r\\n___\\r\\n_ _ _\\r\\n\\r\\n```\\r\\n\\r\\n* * *\\r\\n- 마크다운(MarkDown) 사용법 총정리\\r\\n\\r\\n  <https://www.heropy.dev/p/B74sNE>\",\"n\":0.05}}},{\"i\":4,\"$\":{\"0\":{\"v\":\"Web API\",\"n\":0.707},\"1\":{\"v\":\"\\r\\n## CustomElementRegistry\\r\\n\",\"n\":0.707}}},{\"i\":5,\"$\":{\"0\":{\"v\":\"Basic\",\"n\":1},\"1\":{\"v\":\"\\r\\n## DOM\\r\\n### Real DOM\\r\\n- Svelte\\r\\n- 브라우저가 HTML 파싱하여 생성\\r\\n- `.` dot 표기법으로 accessible\\r\\n- 변경 시 Reflow, Repaint\\r\\n\\r\\n### Shadow DOM\\r\\n- 각 DOM 변경사항이 서로의 요소에 적용되지 않는다.\\r\\n- ex\\\\) `<input>` `<textarea>` `<video>` `<image>`\\r\\n- 스타일을 완전히 분리하고 싶을 때 사용. Third-party Widgets(대화 형 위젯)\\r\\n\\r\\n### Virtual DOM\\r\\n- React, Vue\\r\\n- Virtual DOM을 Virtual DOM2 로 복제(메모리에 복제) 후 비교, 업데이트 위치 감지하여 업데이트된 요소만 변경\\r\\n\\r\\n## Rendering\\r\\n### SSR (Server Side Rendering)\\r\\n> 서버에서 완전히 렌더링 된 HTML 전달\\r\\n- Node.js, Multi Page Application(MPA)\\r\\n- 최초 로딩 속도 빠름\\r\\n- 페이지 이동 시 새로운 HTML 전체 다시 렌더링 (깜빡임, 로딩 속도 느림)\\r\\n- 위 문제 보완하기 위해 AJAX(XMLHttpRequest, fetch, Axios)로 필요한 부분(데이터)만 비동기적으로 업데이트\\r\\n- SEO 친화적\\r\\n\\r\\n### CSR (Client Side Rendering)\\r\\n> HTML, JavaScript 모두 받아온 후 JavaScript를 실행하여 동적으로 페이지 렌더링\\r\\n- Client 요청 &rightarrow; index.html (`<div id=\\\"root\\\"> <script scr=\\\"app.js\\\">`) 서버 응답\\r\\n- 최초 로딩 속도 느림\\r\\n- 로딩 후 실시간 데이터 처리 빠름\\r\\n- index.html 파일 하나로 SEO 문제\\r\\n\\r\\n### SSG (Static Site Generator)\\r\\n- Gatsby\\r\\n- 빌드 시 렌더링 마친 정적 파일들을 generate 하여 배포 &rightarrow; 정적 파일 응답 (초기 로딩 속도 빠름)\\r\\n\\r\\n### Next.js (하이브리드 프레임워크)\\r\\n- SSR과 CSR의 단점을 보완하기위해 만든 React 프레임워크 (SSR, CSR, SSG 모두 지원)\\r\\n- 자동 코드 분할(Automatic Code Splitting) : 각 페이지 로딩 시 필요한 코드만 미리 로드\\r\\n- Hydration (HTML을 React Application 초기화)  \\r\\n\\t: 미리 렌더링 된 HTML에 javascript를 결합  \\r\\n\\tHTML(dummy) &rightarrow; React Application initialized &rightarrow; Interactive App  \\r\\n\\t- Backend에서 렌더 후 명시된(use client) componenet만 hydration\\r\\n\\r\\n## Server\\r\\n### Web Application Server (WAS)\\r\\n> 클라이언트(웹 브라우저)로부터 요청받아 동적인 콘텐츠(데이터베이스 조회) 생성하고 제공\\r\\n\\r\\n### Web Server\\r\\n> 클라이언트(웹 브라우저)에 하이퍼미디어(HTML, CSS, JavaScript, 이미지, API) 응답\\r\\n- port: 80 HTTP/ 443 HTTPS 단일 TCP 연결\\r\\n- FTP (파일 전송 프로토콜)\\r\\n\",\"n\":0.062}}},{\"i\":6,\"$\":{\"0\":{\"v\":\"Gatsby 검색기능\",\"n\":0.707},\"1\":{\"v\":\"\\r\\n## [Fuse.js](https://www.fusejs.io/)\\r\\n> Powerful, lightweight fuzzy-search library, with zero dependencies.  \\r\\n> 주어진 쿼리와 정확히 일치하는 것이 아닌 주어진 패턴과 거의 동일한 문자열을 찾는 기술\\r\\n\\r\\n## [gatsby-plugin-fusejs](https://www.gatsbyjs.com/plugins/gatsby-plugin-fusejs/)\\r\\n- 빌드 시 인덱스 생성(gatsby-plugin-fusejs) &rightarrow; 생성한 인덱스를 런타임(React hook)에 fuse.js 사용\\r\\n```js:title=gatsby-config.js\\r\\nmodule.exports = {\\r\\n\\tplugins: [\\r\\n    {\\r\\n      resolve: `gatsby-plugin-fusejs`,\\r\\n      options: {\\r\\n        query: `\\r\\n\\t\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t\\tallMarkdownRemark {\\r\\n\\t\\t\\t\\t\\t\\t\\tnodes {\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tid\\r\\n\\t\\t\\t\\t\\t\\t\\t\\trawMarkdownBody\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tfrontmatter {\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttitle\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t`,\\r\\n        keys: ['title', 'body'],\\r\\n        normalizer: ({ data }) =>\\r\\n          data.allMarkdownRemark.nodes.map(node => ({\\r\\n            id: node.id,\\r\\n            title: node.frontmatter.title,\\r\\n            body: node.rawMarkdownBody,\\r\\n          })),\\r\\n      },\\r\\n    },\\r\\n\\t]\\r\\n}\\r\\n```\\r\\n\\r\\n```\\r\\n\\r\\n```\\r\\n- useStatiQuery  \\r\\n\\t빌드 시 리액트 훅을 사용하여 GraphQL Data Layer 쿼리\\r\\n\\r\\n\\r\\n\\r\\n* * *\\r\\n\\r\\n\",\"n\":0.112}}}]}","data":[{"id":"0565d7b3-04a1-59fa-a57d-c0f61d85a56f","slug":"/gatsby-starter/","title":"Gatsby 시작하기","categories":["Gatsby","Markdown","GraphQL","TypeScript","EmotionJS"],"body":"\r\n## 특징\r\n\r\n> React, GraphQL 기반 <u>정적 페이지 (Static Site Generator)</u> 생성  \r\n> JAM Stack (Javascript, API, MarkUp Stack) 기반 프레임워크 - 빠르고 안전하고 스케일링 하기 쉬움\r\n\r\n- 서버와 통신, 동적 생성(Next.js)과 달리 서버 없이 정적 사이트 생성\r\n- 빌드 시 각 페이지에 대한 파일 생성, 저장(CDN) 후 요청 시 재사용\r\n- CDN(Content Delivery Network) 통해 제공\r\n- 기업 소개 페이지, 블로그, 포트폴리오 작업에 적합\r\n- 다양한 [플러그인](https://www.gatsbyjs.com/plugins#cms) 사용하여 쉽게 제작 가능\r\n\r\n## Gatsby 프로젝트 생성\r\n\r\n```\r\nnpx gatsby-cli new \"NEW PROJECT\"\r\n```\r\n\r\n### Directory\r\n- contents: 포스트 관련 파일 (markdown, img)\r\n- src\r\n\t- components: React Components\r\n\t- hooks\r\n\t- pages: 파일 명으로 페이지 접근가능\r\n\t- templates: 여러 콘텐츠 Components, Gatsby에서 제공하는 API로 페이지 생성  \r\n\t\t파일명으로 접근 불가\r\n- static: 정적 파일\r\n\r\n### Gatsby Rendering\r\ngatsby-browser.js|gatsby-ssr.js\r\n:---|:---\r\n브라우저(클라이언트) | 서버\r\n페이지 로드 후 | HTML 생성 시\r\n전역 CSS Import, 이벤트 제어, 브라우저 전용 API 사용 시 | mata/script/style preload(폰트)\r\n\r\n- 구글 태그 관리자\r\n```js:title=gatsby-ssr.js\r\n/**\r\n * @type {import('gatsby').GatsbySSR['onRenderBody']}\r\n */\r\nconst { gtmNoscript, gtmScript } = require('./src/components/Common/gtm-tag')\r\n\r\nexports.onRenderBody = ({\r\n  setHtmlAttributes,\r\n  setHeadComponents,\r\n  setPreBodyComponents,\r\n}) => {\r\n  setHtmlAttributes({ lang: `en` })\r\n  setHeadComponents([gtmScript])\r\n  setPreBodyComponents([gtmNoscript])\r\n}\r\n```\r\n\r\n## TypeScript\r\n\r\n> MicroSoft에서 개발, 오픈 소스 프로그래밍 언어  \r\n> Javascript에 타입을 부여한 언어 (Javascript로 컴파일 되어 동작)\r\n\r\n- 컴파일 단계에서 에러를 알려주어 오류 방지\r\n- 변수와 함수의 타입을 알 수 있어 유지보수 용이\r\n\r\n```\r\nyarn add typescript --dev gatsby-plugin-typescript\r\n```\r\n```js:title=gatsby-config.js\r\nmodule.exports = {\r\n\tplugins: [\r\n    {\r\n      resolve: 'gatsby-plugin-typescript',\r\n      options: {\r\n        isTSX: true,\r\n        allExtensions: true,\r\n      },\r\n    },\r\n    ...\r\n  ],\r\n}\r\n```\r\n\r\n```\r\nyarn tsc --init\r\n```\r\n```json:title=tsconfig.json\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"es5\",\r\n    \"module\": \"commonjs\",\r\n    \"allowJs\": true,\r\n    \"noUnusedLocals\": true,\r\n    \"noUnusedParameters\": true,\r\n    \"noImplicitReturns\": true,\r\n    \"baseUrl\": \"./src\",\r\n    \"paths\": {\r\n      \"components/*\": [\"./components/*\"],\r\n      \"utils/*\": [\"./utils/*\"],\r\n      \"hooks/*\": [\"./hooks/*\"]\r\n    },\r\n    \"strict\": true,\r\n    \"jsx\": \"preserve\",\r\n    \"jsxImportSource\": \"@emotion/react\",\r\n    \"esModuleInterop\": true,\r\n    \"skipLibCheck\": true,\r\n    \"forceConsistentCasingInFileNames\": true,\r\n    \"resolveJsonModule\": true\r\n  },\r\n  \"include\": [\"src/**/*.tsx\"],\r\n  \"exclude\": [\"node_modules\"]\r\n}\r\n```\r\n\r\n```js:title=gatsby-node.js\r\n/**\r\n * @type {import('gatsby').GatsbyNode['createPages']}\r\n*/\r\nconst path = require('path')\r\n\r\n// Setup Import Alias\r\nexports.onCreateWebpackConfig = ({ getConfig, actions }) => {\r\n  const output = getConfig().output || {}\r\n\r\n  actions.setWebpackConfig({\r\n    output,\r\n    resolve: {\r\n      alias: {\r\n        components: path.resolve(__dirname, 'src/components'),\r\n        utils: path.resolve(__dirname, 'src/utils'),\r\n        hooks: path.resolve(__dirname, 'src/hooks'),\r\n      },\r\n    },\r\n  })\r\n}\r\n```\r\n\r\n### 함수형 컴포넌트\r\n```tsx\r\nimport {FunctionComponent} from 'react'\r\n\r\nconst SomePage: FunctionComponent = function(){\r\n\treturn <Text />\r\n}\r\nexport default SomePage\r\n```\r\n\r\n### Generic\r\n\r\n클래스나 함수에서 사용할 타입을 미리 명시 후 사용할 때 결정\r\n\r\n```tsx\r\nimport {FunctionComponent} from 'react'\r\n\r\ninterface SomeProps {\r\n\ttext: string\r\n}\r\n\r\nconst SomePage: FunctionComponent<SomeProps> = function(){\r\n\treturn <Text />\r\n}\r\nexport default SomePage\r\n```\r\n\r\n### interface 와 type 차이\r\n- `interface`\r\n\t- 객체 타입 정의 시(공개 API) 사용\r\n\t- extends 확장 가능\r\n\r\n```tsx\r\ninterface SomeProps {\r\n\ttitle: string\r\n}\r\ninterface SomeProps {  // 선언적 확장도 가능\r\n\tbody: string\r\n}\r\ninterface SomeProps2 extends SomeProps {\r\n\tSomeBody: string\r\n}\r\nconst MyContents: SomeProps2 = {\r\n\ttitle: '...',\r\n\tbody: '...',\r\n\tSomeBody: '...',\r\n}\r\n```\r\n\r\n- `type`\r\n\t- 병합 불가\r\n\t- 확장 시 `&` 연산자 사용\r\n\t- computed value 사용 가능\r\n\r\n```tsx\r\ntype SomeProps{\r\n\ttitle: string\r\n} & {\r\n\tbody: string\r\n}\r\n\r\ntype SomeArray = {\r\n\t[key in Somes]: string\r\n}\r\n```\r\n\r\n## EmotionJS\r\n\r\n> styled-components 의 기능과 거의 동일하며 번들 용량이 작다\r\n\r\n```\r\nyarn add gatsby-plugin-emotion @emotion/react @emotion/styled\r\n```\r\n```js:title=gatsby-config.js\r\nmodule.exports = {\r\n\tplugins: [\r\n\t\t...\r\n    `gatsby-plugin-emotion`,\r\n    ...\r\n  ],\r\n}\r\n```\r\n\r\n### Global 스타일 지정 방법\r\n```tsx\r\nimport { Global, css } from '@emotion/react'\r\nconst defaultStyle = css`\r\n  body {\r\n    margin: 0;\r\n    padding: 0;\r\n    font-family: Pretendard, system-ui, -apple-system, BlinkMacSystemFont,\r\n      'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans',\r\n      'Helvetica Neue', sans-serif;\r\n    color: #333;\r\n  }\r\n`\r\nconst GlobalStyle: FunctionComponent = function () {\r\n  return <Global styles={defaultStyle} />\r\n}\r\nexport default GlobalStyle\r\n```\r\n\r\n### css 정의 및 적용\r\n```tsx\r\nimport { css } from '@emotion/react'\r\nconst SomeStyle = css`\r\n\tfont-size:14px;\r\n`\r\n...\r\n<div css={SomeStyle}></div>\r\n...\r\n```\r\n\r\n### Styled Component 생성 1 : .(dot)을 통해 함수 호출\r\nKebab Case\r\n```tsx\r\nimport { styled } from '@emotion/react'\r\nconst SomeStyledComponent = styled.div`\r\n\tfont-size:14px;\r\n`\r\n<SomeStyledComponent></SomeStyledComponent>\r\n```\r\n\r\n### Styled Component 생성 2 : 객체\r\nCamel Case, 스타일 값은 String Type으로 전달\r\n```tsx\r\nimport { styled } from '@emotion/react'\r\nconst SomeComponent = styled('div')(() =>({\r\n\tfontSize: '14px'\r\n}))\r\n<SomeComponent></SomeComponent>\r\n```\r\n\r\n### Styled Component에서 Props\r\n\r\n```tsx\r\nconst SomeStyledComponent = styled.div<{ disable: boolean }>`\r\n\ttext-decoration: ${({ disable })=>( disable ? `line-through` : `none`)}\r\n`\r\n```\r\n```tsx\r\nconst SomeComponent = styled('div')<{ disable: boolean}>(({ disable })=>({\r\n\ttextDecoration: disable ? `line-through` : `none`,\r\n}))\r\n```\r\n```tsx\r\nconst Component = styled(({ active, ...props }: Props타입명시) =>(\r\n\t<Link {...props} />\r\n)) <Some타입명시>`\r\n\tfont-size: 14px;\r\n`\r\n```\r\n\r\n## Gatsby에서 [Markdown](/markdown-syntax) 파일 사용하기\r\n\r\n### Remark\r\n> Markdown을 처리하기 위한 자바스크립트 기반 파서\r\n\r\n- 변환된 추상 구문 트리(AST, Abstract syntax tree)를 이용하여 다른 플러그인으로 확장\r\n- 변환된 AST를 HTML로 변환하여 컴포넌트 출력\r\n\r\n> [Markdown] &rightarrow; Remark &rightarrow; AST(mdast) &rightarrow; AST 노드에 플러그인 접근(수정, 추가, 삭제) &rightarrow;  \r\n> [GraphQL 스키마](#graphql) 생성, 매핑 &rightarrow; [HTML], React 컴포넌트\r\n\r\n### Markdown 라이브러리\r\n- gatsby-source-filesystem  \r\n\t: 변환할 파일 정보 제공 (다른 라이브러리와 연계(~-transformer, ~-images), GraphQL 연결)\r\n- gatsby-transformer-remark  \r\n\t: HTML로 변환\r\n- gatsby-remark-images     \r\n\t: 이미지 최적화 (반응형, loading lazy)\r\n- gatsby-remark-prismjs & prismjs  \r\n\t: code 하이라이팅\r\n- gatsby-remark-smartypants  \r\n\t: 문장부호 타이포그래피 가독성 좋게 자동 변환 (ex quotes ' \" , ... ---)\r\n- gatsby-remark-autolink-headers  \r\n\t: header 바로가기 링크\r\n- gatsby-remark-copy-linked-files  \r\n\t: 사용되는 파일 static 경로로 복사 > 빌드 후에도 링크 유효\r\n- gatsby-remark-external-links  \r\n\t: 사용되는 링크 태그 속성 지정 (target, rel)\r\n- gatsby-omni-font-loader  \r\n\t: web font\r\n\r\n```\r\nyarn add gatsby-transformer-remark gatsby-remark-images gatsby-remark-prismjs prismjs gatsby-remark-smartypants gatsby-remark-copy-linked-files gatsby-remark-external-links\r\n```\r\n\r\n```js:title=gatsby-config.js\r\nmodule.exports = {\r\n\t...\r\n\tplugins: [\r\n\t\t{\r\n\t\t\tresolve: `gatsby-plugin-typescript`,\r\n\t\t\toptions: {\r\n\t\t\t\tisTSX: true,\r\n\t\t\t\tallExtensions: true,\r\n\t\t\t},\r\n\t\t},\r\n\t\t`gatsby-plugin-emotion`,\r\n\t\t{\r\n\t\t\tresolve: `gatsby-source-filesystem`,\r\n\t\t\toptions: {\r\n\t\t\t\tname: `contents`,\r\n\t\t\t\tpath: `${__dirname}/contents`,\r\n\t\t\t},\r\n\t\t},\r\n\t\t{\r\n\t\t\tresolve: `gatsby-source-filesystem`,\r\n\t\t\toptions: {\r\n\t\t\t\tname: `images`,\r\n\t\t\t\tpath: `${__dirname}/static`,\r\n\t\t\t},\r\n\t\t},\r\n\t\t`gatsby-transformer-sharp`,\r\n\t\t`gatsby-plugin-sharp`,\r\n\t\t{\r\n\t\t\tresolve: `gatsby-omni-font-loader`,\r\n\t\t\toptions: {\r\n\t\t\t\tenableListener: true,\r\n\t\t\t\tpreconnect: [`https://cdn.jsdelivr.net/gh/orioncactus/pretendard`],\r\n\t\t\t\tweb: [\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tname: `Pretendard`,\r\n\t\t\t\t\t\tfile: `https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard-dynamic-subset.min.css`,\r\n\t\t\t\t\t},\r\n\t\t\t\t],\r\n\t\t\t},\r\n\t\t},\r\n\t\t{\r\n\t\t\tresolve: `gatsby-transformer-remark`,\r\n\t\t\toptions: {\r\n\t\t\t\tplugins: [\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tresolve: `gatsby-remark-smartypants`,\r\n\t\t\t\t\t\toptions: {\r\n\t\t\t\t\t\t\tdashes: `oldschool`,\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t},\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tresolve: `gatsby-remark-autolink-headers`,\r\n\t\t\t\t\t\toptions: {\r\n\t\t\t\t\t\t\tclassName: `link-headers`,\r\n\t\t\t\t\t\t\telements: [`h2`],\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t},\r\n\t\t\t\t\t`gatsby-remark-code-titles`,\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tresolve: `gatsby-remark-prismjs`,\r\n\t\t\t\t\t\toptions: {\r\n\t\t\t\t\t\t\tclassPrefix: `language-`,\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t},\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tresolve: `gatsby-remark-images`,\r\n\t\t\t\t\t\toptions: {\r\n\t\t\t\t\t\t\tmaxWidth: 768,\r\n\t\t\t\t\t\t\tquality: 100,\r\n\t\t\t\t\t\t\twithWebp: true,\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t},\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tresolve: `gatsby-remark-copy-linked-files`,\r\n\t\t\t\t\t\toptions: {},\r\n\t\t\t\t\t},\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tresolve: `gatsby-remark-external-links`,\r\n\t\t\t\t\t\toptions: { target: `_blank`, rel: `nofollow` },\r\n\t\t\t\t\t},\r\n\t\t\t\t],\r\n\t\t\t},\r\n\t\t},\r\n\t\t...\r\n\t],\r\n}\r\n```\r\n\r\ncode 테마 적용\r\n```js:title=gatsby-browser.js\r\nimport 'prismjs/themes/prism-tomorrow.css';\r\n```\r\n\r\n## GraphQL\r\n\r\n> 페이스북 쿼리언어  \r\n> 클라이언트가 요청한 데이터(필요한 데이터)만 가져온다\r\n\r\n### Gatsby에서 GraphQL 사용하기\r\n\r\n#### GraphiQL (IDE)\r\n```\r\nView GraphiQL, an in-browser IDE, to explore your site's data and schema\r\n\r\n\thttp://localhost:8000/___graphql \r\n```\r\n\r\n- 홈페이지의 메타데이터, 마크다운 데이터, 이미지 데이터를 Query하여 얻을 수 있다.\r\n- 직접 생성한 페이지(src/pages/) 또는 Gatsby가 제공한 페이지(Node API `createPages`)에서 Query 정의 가능하다.\r\n\r\n> GraphQL 스키마(Query 정의) &rightarrow; Query export(질의) &rightarrow; Gatsby 요청/응답 &rightarrow; 데이터를 Props(키 값 data)로 전달\r\n\r\n- GraphQL 스키마 (데이터 구성 방식) : 데이터 사용 전 타입 정의\r\n\r\n```tsx\r\nimport { graphql } from 'gatsby'\r\ntype SomeContentProps = {  // GraphQL 스키마 정의\r\n\tdata: {\r\n\t\tsomeQuery:{\r\n\t\t\tsome: string\r\n\t\t}\r\n\t}\r\n}\r\nconst SomeContent: FunctionComponent<SomeContentProps> = function({\r\n\t// 데이터 (결과)\r\n\tdata: {\r\n\t\tsomeQuery: {\r\n\t\t\tsome\r\n\t\t}\r\n\t}\r\n}) {\r\n\treturn(\r\n\t\t<div> {some} </div>\r\n\t)\r\n}\r\nexport default SomeContent\r\n\r\nexport const someQuery = graphql`  // Query export(질의)\r\n\tquery someQuery { // 디버깅 시 로그에서 쿼리 이름(someQuery) 확인 가능\r\n\t\t{\r\n\t\t\tsome{}\r\n\t\t}\r\n\t}\r\n`\r\n```\r\n\r\n### Markdown 파일에서 GraphQL (gatsby-transformer-remark 라이브러리)\r\n- MarkdownRemark : 파일 1개\r\n- allMarkdownRemark : 파일 여러개\r\n- file : 이미지, 파일\r\n- edges : 연결 (배열)\r\n- node : 개별 실제 데이터\r\n- frontmatter : 상단 메타데이터\r\n\r\n```tsx\r\nimport { graphql } from 'gatsby'\r\ntype SomePageProps = {\r\n\tdata:{\r\n\t\tallMarkdownRemark:{\r\n\t\t\tedges: {node:{id...}}\r\n\t\t}\r\n\t\tfile:{\r\n\t\t\tchildrenImagesharp: string\r\n\t\t}\r\n\t}\r\n}\r\nconst SomePage: FunctionComponent<SomePageProps> = function({\r\n\tdata: {\r\n\t\tallMarkdownRemark: {edges},\r\n\t\tfile:{\r\n\t\t\tchildrenImageSharp: {gatsbyImageData},\r\n\t\t}\r\n\t}\r\n}) {\r\n\r\n\treturn (<div />)\r\n}\r\nexport default SomePage\r\n\r\nexport const SomeQuery = graphql`\r\n\tquery SomeQuery {\r\n\t\tallMarkdownRemark(sort){\r\n\t\t\tedges{\r\n\t\t\t\tnode{\r\n\t\t\t\t\tid\r\n\t\t\t\t\tfrontmatter{ title summary....}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfile(name: {} ){\r\n\t\t\tchildImageSharp{\r\n\t\t\t\tgatsbyImageData(width:..., height:,,,)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n`\r\n```\r\n\r\n## Gatsby Link API\r\n- 경로를 to(props)로 전달\r\n- 페이지의 Link 모두 찾은 후 모든 페이지(to=\"경로\") Prefetch > 로딩 속도 빠름\r\n\r\n* * *\r\n- React 기반 Gatsby로 기술 블로그 개발하기\r\n\r\n  <https://www.inflearn.com/course/gatsby-기술블로그/dashboard>"},{"id":"59952527-17fe-5070-b640-96752ba99d27","slug":"/gatsby-pages/","title":"Gatsby 페이지 구현하기","categories":["Gatsby","React"],"body":"\r\n## query-string\r\n> URL의 Query String(search parameters) 객체로 변환\r\n\r\n- URL Query String : 엔드포인트 주소 이후 ?parameter=value\r\n- 여러개일 경우 `&` : \\~/?key=value&key=value\r\n```tsx\r\nimport queryString, { ParsedQuery } from 'query-string'\r\n\r\nconst somePage: FunctionComponent<~Props> = function(){\r\n\tconst parsed: ParsedQuery<string> = queryString.parse(location.search)\r\n\tconst selected: string =\r\n\t\ttypeof parsed.someCategory !== 'string' || !parsed.someCategory\r\n\t\t\t? 'All' \r\n\t\t\t: parsed.someCategory\r\n\r\n\treturn <div />\r\n}\r\n```\r\n- location.search : [Gatsby page 컴포넌트]의 기본 props(ex location.pathname, location.hash...)\r\n\r\n## List Paint\r\n> `Array.prototype.reduce()`, `Array.prototype.filter()` 메서드 사용\r\n```javascript\r\narray.reduce((accumulator, current)=>{\r\n\t...\r\n\treturn accumulator;\r\n}, {initialValue})\r\n```\r\n```javascript\r\narray.filter((sort) => result)\r\n// array 반환\r\n// true : 배열에 요소 유지 | false : 배열에 요소 제거\r\n```\r\n\r\n```tsx\r\nconst somePage: FunctionComponent<~Props> = function(){\r\n\tconst listTabs = useMemo(()=>\r\n\t\tdata.reduce((list, {node:{ frontmatter: { querys }}}) =>{\r\n\t\t\tquerys.forEach((query)=>{\r\n\t\t\t\tquery in list ? list[query]++ : (list[query] = 1)\r\n\t\t\t})\r\n\t\t\tlist['All']++\r\n\t\t\treturn list\r\n\t\t},{ All: 0 })\r\n\t,[])\r\n\r\n\tconst data = useMemo(() => (\r\n\t\t\titems.filter({node:{someCategory}}) =>\r\n\t\t\t\tselected === 'All' ? true : someCategory.includes(selected)\r\n\r\n\t\t), [selected]\r\n\t)\r\n\r\n\treturn (\r\n\t\t<Template>\r\n\t\t\t<Tabs listTabs={listTabs} />\r\n\t\t\t<ListWrapper ref={}> // Infinity Scroll\r\n\t\t\t\t{data.map(\r\n\t\t\t\t\t({node:{props, slug}}) => <Item {...props} link={slug} />\r\n\t\t\t\t)}\r\n\t\t\t</ListWrapper>\r\n\t\t</Template>\r\n\t)\r\n}\r\n```\r\n\r\n## Infinity Scroll\r\n- List와 hook 참조 시킨 후 원하는 갯수 만큼 props의 데이터 잘라내 반환  \r\n\tList: `<ListWrapper ref={containerRef}>`  \r\n\t원하는 갯수: `const [count, setCount] = useState<number>(1)`\r\n\r\n```tsx:title=List.tsx\r\nconst List: FunctionComponent<ListProps> =({ propsData }) =>{\r\n\tconst { containerRef, itemsList } = hook( propsData )\r\n\treturn(\r\n\t\t<ListWrapper ref={containerRef}>\r\n\t\t\t{itemsList.map(\r\n\t\t\t\t({node:{props, slug}}) => (\r\n\t\t\t\t\t<Item {...props} link={slug} />\r\n\t\t\t\t)\r\n\t\t\t)}\r\n\t\t</ListWrapper>\r\n\t)\r\n}\r\n```\r\n\r\n```tsx:title=hook.tsx\r\nconst hook = ({ propsData }) => {\r\n\tconst containerRef = MutableRefObject<HTMLDivElement | null> = useRef<HTMLDivElement>(null)\r\n\tconst observer: MutableRefObject<IntersectionObserver | null> = useRef<IntersectionObserver>(null)\r\n\tconst [count, setCount] = useState<number>(1)\r\n\r\n\tconst itemsData = [...propsData] // propsData 필터 하기(propsData.filter((selected) => true array)\r\n\r\n\tuseEffect(()=>{\r\n\t\tobserver.current = new IntersectionObserver((entries, observer) =>{\r\n\t\t\t\tif (!entries[0].isIntersecting) return\r\n\t\t\t\tsetCount(val => val + 1)\r\n\t\t\t\tobserver.unobserve(entries[0].target)\r\n\t\t\t},\r\n\t\t\t{ threshold:1 },\r\n\t\t)\r\n\t}, [])\r\n\r\n\tuseEffect(() =>{\r\n\t\tif(데이터 없을 시, 데이터 적을 시 ||\r\n\t\t\tcontainerRef.current === null ||\r\n\t\t\tcontainerRef.current.children.length === 0\r\n\t\t)\r\n\t\t\treturn\r\n\t\t\r\n\t\t// 감지 할 object : 제일 마지막 children\r\n\t\tobserver.current.observe(\r\n\t\t\tcontainerRef.current.children[containerRef.current.children.length - 1]\r\n\t\t)\r\n\t}, [count])\r\n\r\n\treturn{\r\n\t\tcontainerRef,\r\n\t\titemsList: itemsData.slice(0, count);\r\n\t}\r\n}\r\n```\r\n\r\n## onCreateNode (Gatsby API)\r\n> MarkdownRemark 데이터에 Slug 필드 생성하기\r\n\r\n### Slug\r\n- 특정 페이지의 제목을 핵심 키워드 조합으로 식별하기 위해 만드는 방법\r\n- URL 경로에 사용 (SEO 친화적)\r\n\r\n- [gatsby-source-filesystem](/gatsby-starter/#gatsby에서-markdown-파일-사용하기) 라이브러리를 통해 root(`${__dirname}`)/contents/ 내의 모든 마크다운 파일들마다 파일위치,파일 명으로 Slug 생성\r\n```js:title=gatsby-node.js\r\nconst path = require('path')\r\nconst { createFilePath } = require(`gatsby-source-filesystem`)\r\n\r\nexports.onCreateNode = ({ node, getNode, actions }) => {\r\n\tconst { createNodeField } = actions\r\n\tif (node.internal.type === `MarkdownRemark`) {\r\n\t\tconst slug = createFilePath({ node, getNode })\r\n\t\tcreateNodeField({ node, name: 'slug', value: slug })\r\n\t}\r\n}\r\n```\r\n\r\n## createPages (Gatsby API)\r\n> 생성한 Slug로 페이지 생성하기\r\n\r\n1. 마크다운 데이터의 모든 slug 조회 (graphql), 날짜 제목 내림차순(sort)\r\n2. 조회 한 slug의 데이터 생성(queryAllMarkdownData), 없을 시 에러 (reporter.panicOnBuild: 개발 시 서버 실행, 빌드 시 중단)\r\n3. 생성 한 데이터(queryAllMarkdownData)를 통해 페이지 생성  \r\n\t`queryAllMarkdownData.forEach(({node:{ fields: { slug } }}) => ...createPage(pageOptions))` : `generatePage`\r\n4. `createPage`의 옵션 (객체 형식)\r\n\t- path - slug 데이터 그대로 사용(url)\r\n\t- component - path 라이브러리를 통해 불러온 템플릿\r\n\t- context: { slug } - 이 데이터(slug 객체)는 템플릿 컴포넌트(`src/templates/some_template.tsx`)에서 **Props**로 받을 수 있으며 **GraphQL Query 파라미터**로 받을 수 있다.\r\n\r\n```tsx:title=src/templates/some_template.tsx\r\nimport React, { FunctionComponent } from 'react'\r\n\r\nconst someTemplate: FunctionComponent<~Props> = function (props) {\r\n  console.log(props)\r\n\r\n  return <div></div>\r\n}\r\n\r\nexport default someTemplate\r\n```\r\n```js:title=gatsby-node.js\r\nconst path = require('path')\r\n\r\nexports.createPages = async ({ actions, graphql, reporter }) => {\r\n\tconst { createPage } = actions\r\n\r\n\tconst queryAllMarkdownData = await graphql(\r\n\t\t`\r\n\t\t\t{\r\n\t\t\t\tallMarkdownRemark(\r\n\t\t\t\t\tsort: {\r\n\t\t\t\t\t\torder: DESC\r\n\t\t\t\t\t\tfields: [frontmatter___date, frontmatter___title]\r\n\t\t\t\t\t}\r\n\t\t\t\t) {\r\n\t\t\t\t\tedges {\r\n\t\t\t\t\t\tnode {\r\n\t\t\t\t\t\t\tfields {\r\n\t\t\t\t\t\t\t\tslug\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t`,\r\n\t)\r\n\r\n\t// Handling GraphQL Query Error\r\n\tif (queryAllMarkdownData.errors) {\r\n\t\treporter.panicOnBuild(`Error While running query`)\r\n\t\treturn\r\n\t}\r\n\r\n\t// Import Post Template Component\r\n\tconst PostTemplateComponent = path.resolve(\r\n\t\t__dirname,\r\n\t\t`src/templates/some_template.tsx`,\r\n\t)\r\n\r\n\t// Page Generating Function\r\n\tconst generatePage = ({\r\n\t\tnode: {\r\n\t\t\tfields: { slug },\r\n\t\t},\r\n\t}) => {\r\n\t\tconst pageOptions = {\r\n\t\t\tpath: slug,\r\n\t\t\tcomponent: PostTemplateComponent,\r\n\t\t\tcontext: { slug },\r\n\t\t}\r\n\t\tcreatePage(pageOptions)\r\n\t}\r\n\t// Generate Post Page And Passing Slug Props for Query\r\n\tqueryAllMarkdownData.data.allMarkdownRemark.edges.forEach(generatePage)\r\n}\r\n```\r\n\r\n## 템플릿 컴포넌트 데이터 조회하기\r\n### GraphQL Query 파라미터 Template에서 받기\r\n- query내에서 파라미터 사용 시 필드와 구분하기 위해 `$` 접두사 붙인 후 타입 명시(타입 명 - 대문자 시작)\r\n- context 데이터 객체 내의 Props와 동일한 key 값으로 설정\r\n- `eq:`(equal) property로 slug와 일치하는 마크다운 데이터만 query\r\n```tsx:title=src/templates/some_template.tsx\r\n...\r\nquery queryMarkdownDataBySlug($slug: String){\r\n\tallMarkdownRemark(filter: { fields: { slug: { eq: $slug } } }) {edges{node...}}\r\n}\r\n```\r\n\r\n## Markdown 문서 HTML 출력\r\n> __html key에 HTML 태그로 변환되어 문자열로 저장 (frontmatter 제외)\r\n```tsx\r\ninterface ContentProps{\r\n\thtml: string\r\n}\r\nconst Content: FunctionComponent<ContentProps> = ({html}) =>{\r\n\treturn <Some dangerouslySetInnerHTML={{_html: html}}>\r\n}\r\n```\r\n\r\n## Meta Tag\r\n\r\n### React-Helmet\r\n```\r\nyarn add @types/react-helmet\r\n```\r\n- 중복된 경우 나중에 정의된 태그 적용\r\n```tsx\r\nimport { Helmet } from 'react-helmet'\r\n\r\nconst Template: FunctionComponent<TemplateProps> = function({\r\n\ttitle,\r\n\tdescriptions,\r\n\turl,\r\n\t...\r\n}){\r\n\treturn(\r\n\t\t<Wrapper>\r\n\t\t\t<Helmet>\r\n\t\t\t\t<title>WebSite</title>\r\n\t\t\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n        <meta httpEquiv=\"Content-Type\" content=\"text/html;charset=UTF-8\" />\r\n\r\n\t\t\t\t<meta property=\"og:title\" content={title} />\r\n\t\t\t\t<meta property=\"og:description\" content={description} />\r\n\t\t\t\t<meta property=\"og:image\" content={image} />\r\n\t\t\t\t<meta property=\"og:url\" content={url} />\r\n\t\t\t\t<meta property=\"og:site_name\" content={title} />\t\t\t\t\r\n\t\t\t</Helmet>\r\n\t\t\t...\r\n\t\t</Wrapper>\r\n\t)\r\n}\r\n```\r\n### GraphQL로 각 페이지 Helmet에 데이터 전달\r\n\r\n```js:title=gatsby-config.js\r\nmodule.exports = {\r\n  siteMetadata: {\r\n    title: `Gatsby Test Site`,\r\n    description: `블로그 입니다.`,\r\n    author: `@Mee`,\r\n    siteUrl: `~/test-gatsby/`,\r\n  },\r\n}\r\n```\r\n\r\n#### Main\r\n```tsx:title=index.tsx\r\ntype IndexProps = {\r\n\t...\r\n\tdata: {\r\n\t\tsite: {\r\n\t\t\tshiteMetadata: {\r\n\t\t\t\ttitle: string\r\n\t\t\t\tdescription: string\r\n\t\t\t\tsiteUrl: string\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t...\r\n\tfile: {\r\n\t\tpublicURL: string\r\n\t}\r\n}\r\n\r\nconst Index: FunctionComponent<IndexProps> = function({\r\n\tdata: {\r\n\t\tsite: {\r\n\t\t\tsiteMetadata: {title, description, siteUrl}\r\n\t\t}\r\n\t}\r\n}) {\r\n\treturn (\r\n\t\t<Template\r\n\t\t\ttitle={title}\r\n      description={description}\r\n      url={siteUrl}\r\n      image={publicURL}\r\n\t\t/>\r\n\t)\r\n}\r\n\r\nexport const getIndex = graphql`\r\n\tquery getIndex {\r\n\t\tsite{\r\n\t\t\tsiteMetadata{\r\n\t\t\t\ttitle\r\n\t\t\t\tdescription\r\n\t\t\t\tsiteUrl\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n`\r\n```\r\n- publicURL(static 경로) : 원본 파일 그대로 가져올 때 사용\r\n\r\n#### Sub\r\n```tsx:title=template.tsx\r\ntype TemplateProps = {\r\n\t...\r\n\tlocation: {\r\n\t\thref: string\r\n\t}\r\n}\r\n\r\nconst Template: FunctionComponent<TemplateProps> = function({\r\n\t...\r\n\tlocation: { href },\r\n}) {\r\n\r\n\treturn (\r\n\t\t<Template\r\n\t\t\ttitle={title}\r\n      description={summary}\r\n      url={href}\r\n      image={publicURL}\r\n\t\t/>\r\n\t)\r\n}\r\n\r\nexport const queryMarkdown = graphql`\r\n\tquery queryMarkdown($slug: String) {\r\n\t\tallMarkdownRemark(sort){\r\n\t\t\tedges {\r\n\t\t\t\tnode{ ... }\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n`\r\n```\r\n\r\n## Canonical Link\r\n> 중복된 페이지 중 표준으로 사용되는 URL이 무엇인지 검색 엔진에 알려주는 메타 태그\r\n\r\n- 검색 엔진 임의로 표준 지정 방지\r\n- 중복 콘텐츠로 SEO 분산 방지\r\n- 크롤링 효율성 향상\r\n\r\n### 중복된 페이지 발생 이유\r\n- 디바이스 별 구분된 웹사이트(적응형)\r\n- url 쿼리 스트링 사용\r\n\r\n```html\r\n<head>\r\n\t<link rel=\"canonical\" href=\"https://www.~.com\" />\r\n</head>\r\n```\r\n- 절대경로로 작성\r\n- 태그 중첩하지 않도록 작성\r\n\r\n### Gatsby Canonical 라이브러리\r\n```\r\nyarn add gatsby-plugin-canonical-urls\r\n```\r\n```js:title=gatsby-config.js\r\nmodule.exports = {\r\n\tplugins: [\r\n\t\t{\r\n\t\t\tresolve: `gatsby-plugin-canonical-urls`,\r\n\t\t\toptions: {\r\n\t\t\t\tsiteUrl: `https://www.~.com`,\r\n\t\t\t\tstripQueryString: true,\r\n\t\t\t},\r\n\t\t},\r\n\t],\r\n};\r\n```\r\n- stripQueryString : 쿼리 스트링 제거 옵션\r\n\r\n## Sitemap\r\n```\r\nyarn add gatsby-plugin-sitemap\r\n```\r\n```js:title=gatsby-config.js\r\nmodule.exports = {\r\n\tplugins: [\r\n\t\t'gatsby-plugin-sitemap',\r\n\t],\r\n};\r\n```\r\n- sitemap-0.xml, sitemap-1.xml (특정 갯수 이상 일 경우 sitemap 인식 못하는 문제 해결)\r\n\r\n## robots.txt\r\n```\r\nyarn add gatsby-plugin-robots-txt\r\n```\r\n```js:title=gatsby-config.js\r\nmodule.exports = {\r\n\tplugins: [\r\n\t\t{\r\n\t\t\tresolve: 'gatsby-plugin-robots-txt',\r\n\t\t\toptions: {\r\n\t\t\t\tpolicy: [{ userAgent: '*', allow: '/' }],\r\n\t\t\t},\r\n\t\t},\r\n\t],\r\n};\r\n```\r\n\r\n* * *\r\n- React 기반 Gatsby로 기술 블로그 개발하기  \r\n  <https://www.inflearn.com/course/gatsby-기술블로그/dashboard>\r\n\r\n- [표준 URL을 지정 하는 방법](https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls?hl=ko&visit_id=638652447901198736-2506116594&rd=1#rel-canonical-link-method)"},{"id":"be2139ae-47e7-517e-bab0-c363b4fe8187","slug":"/lottie/","title":"Lottie","categories":["Lottie"],"body":"\r\n> 에어비엔비에서 개발한 JSON 기반 애니메이션 오픈 소스 라이브러리  \r\n- Adobe After Effects 애니메이션을 JSON 기반 데이터로 추출\r\n- 벡터 기반\r\n\r\n### [Lottie Player](https://github.com/LottieFiles/lottie-player)\r\n```html\r\n<script src=\"https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js\"></script>\r\n<lottie-player src=\"ex.json\"></lottie-player>\r\n```\r\n\r\n### [dotLottie](https://github.com/LottieFiles/dotlottie-web) (.lottie)\r\n> Lottie.json의 새로운 압축 포맷\r\n```html\r\n<script src=\"https://unpkg.com/@dotlottie/player-component@2.7.12/dist/dotlottie-player.mjs\" type=\"module\"></script>\r\n<dotlottie-player src=\"ex.json / ex.lottie\"></dotlottie-player>\r\n```\r\n- 파일끼리 아카이빙 가능\r\n\r\n## [Lottie Interactivity](https://lottiefiles.com/interactivity)\r\n> Event 라이브러리\r\n```html\r\n<script src=\"https://unpkg.com/@lottiefiles/lottie-interactivity@latest/dist/lottie-interactivity.min.js\"></script>\r\n```\r\n"},{"id":"0360fbad-208a-5f06-b29b-7d694d4c0c3c","slug":"/markdown-syntax/","title":"Markdown syntax","categories":["Markdown","Gatsby"],"body":"\r\n## Markdown\r\n\r\n> 복잡한 MarkUp 태그 문법을 글 작성에 집중할 수 있도록 경량화한 언어  \r\n> Markdown syntax 는 HTML 태그로 변환되어 출력\r\n\r\n### 장점\r\n\r\n- 문법이 쉽다.\r\n- 읽고, 쓰고, 편집하기 쉽다.\r\n- 지원 가능 플랫폼과 프로그램이 다양하기 때문에 호환성이 높다.\r\n- 플랫폼 이동 시 작성한 문서를 다시 옮길 작업이 필요없다.\r\n\r\n### 단점\r\n\r\n- 표준이 없어 사용자마다 문법이 다르다.\r\n- 모든 HTML 마크업을 대체하지 못한다.\r\n\r\n## 제목\r\n\r\n> 1~6개의 `#` 추가\r\n\r\n```markdown\r\n# h1 \r\n## h2\r\n### h3\r\n#### h4\r\n##### h5\r\n###### h6\r\n```\r\n\r\n`<h1>` 태그는 문서당 하나만 사용\r\n\r\n## 텍스트 스타일\r\n\r\n> 마크다운에서 지원하지 않는 태그 직접 사용가능 (`<ins>` `<u>`)\r\n\r\n스타일|구문|출력\r\n:---|:---|:---\r\n이탤릭체 | `*기울임*` `_기울임_ ` | *기울임*\r\n볼드 | `**굵게**` `__굵게__ ` | **굵게**\r\n이탤릭체 볼드 | `***기울임 굵게***` | ***기울임 굵게***\r\n취소선 | `~취소선~` `~~취소선~~` | ~취소선~\r\n언더라인 | `<ins>밑줄</ins>` `<u>밑줄</u>` | <ins>밑줄</ins>\r\n\r\n## 목록\r\n\r\n> `<ol>` `<ul>` `<li>` 태그로 변환  \r\n> 들여쓰기(tab)로 하위 목록 작성 가능\r\n\r\n- 순서 있는 목록 `<ol>`: 숫자 기입, 순서대로 숫자를 매긴다.\r\n- 순서 없는 목록 `<ul>`: `-` `*` `+` 기입\r\n\r\n```markdown\r\n1. 순서1\r\n1. 순서2\r\n1. 순서3\r\n\t1. 순서 3-1\r\n\t1. 순서 3-2\r\n\t1. 순서 3-3\r\n\r\n- 순서가 없는 항목\r\n- 순서가 없는 항목\r\n\t- 순서가 없는 항목\r\n\t- 순서가 없는 항목\r\n\t\t- 순서가 없는 항목\r\n\t\t* 순서가 없는 항목\r\n\t\t+ 순서가 없는 항목\r\n```\r\n\r\n1. 순서1\r\n1. 순서2\r\n1. 순서3\r\n\t1. 순서 3-1\r\n\t1. 순서 3-2\r\n\t1. 순서 3-3\r\n\r\n- 순서가 없는 항목\r\n- 순서가 없는 항목\r\n\t- 순서가 없는 항목\r\n\t- 순서가 없는 항목\r\n\t\t- 순서가 없는 항목\r\n\t\t* 순서가 없는 항목\r\n\t\t+ 순서가 없는 항목\r\n\r\n### 작업 목록\r\n\r\n> 목록 항목 앞에 하이픈 `-` + 공백 + `[ ]` or `[x]` (공백 유의)\r\n\r\n```markdown\r\n- [ ] 작업중\r\n- [x] 작업완료\r\n```\r\n- [ ] 작업중\r\n- [x] 작업완료\r\n\r\n## 텍스트 인용\r\n\r\n> `>` 사용하여 텍스트 인용\r\n\r\n```markdown\r\n> 여러줄도 <br>\r\n> 가능\r\n```\r\n\r\n> 여러줄도 <br>\r\n> 가능\r\n\r\n## Code 블록\r\n\r\n> `<code>` 태그로 변환하여 코드 표현\r\n\r\n### 1. 인라인\r\n\r\n- `<code>` 태그로 변환\r\n- 백틱 \\` 으로 감싼다.\r\n\r\n```markdown\r\n`인라인 코드`\r\n```\r\n`인라인 코드`\r\n\r\n### 2. 블록\r\n\r\n- `<pre>` + `<code>` 태그로 변환\r\n- 백틱 3개 이상 사용하여 블록 안으로 코드 또는 텍스트 서식 지정  \r\n- 백틱의 시작과 종료 갯수가 같아야 한다. (아래 예시는 백틱 3개)\r\n\r\n````markdown\r\n```css\r\n.someClass {\r\n  color:#000;\r\n}\r\n```\r\n````\r\n\r\n```css\r\n.someClass {\r\n  color:#000;\r\n}\r\n```\r\n\r\n` ```html `\r\n```html\r\n<div> Some </div>\r\n```\r\n\r\n` ```javascript `\r\n```Javascript\r\nfunction some (){}\r\n```\r\n\r\n### 3. 타이틀\r\n````markdown\r\n```tsx:title=Title.tsx\r\n<Some />\r\n```\r\n````\r\n```tsx:title=Title.tsx\r\n<Some />\r\n```\r\n\r\n## 테이블\r\n\r\n- 3개 이상의 `-`(hyphen) 사용하여 헤더 구분  \r\n- `:` (colons) 위치로 align  \r\n- 가장 좌측, 우측 `|` 생략 가능 (플랫폼에 따라 불가한 경우도 있음)\r\n\r\n```markdown\r\n|th|th|th|\r\n|:---|:---|:---|\r\n|td|td|td|\r\n|td|td|td|\r\n\r\nth|th|th\r\n:---|:---:|---:\r\n좌측정렬|가운데정렬|우측정렬\r\ntd|td|td\r\n\r\n```\r\nth|th|th\r\n---|---|---\r\ntd|td|td\r\ntd|td|td\r\n\r\nth|th|th\r\n:---|:---:|---:\r\n좌측정렬|가운데정렬|우측정렬\r\ntd|td|td\r\n\r\n## 줄바꿈\r\n\r\n> 마지막 문장에서 띄어쓰기 2번 이상 입력 또는 `<br>`\r\n\r\n```markdown\r\n줄바꿈  \r\n입니다\r\n```\r\n줄바꿈  \r\n입니다\r\n\r\n## 링크\r\n\r\n> `<a>` 변환\r\n\r\n```markdown\r\n1. 외부 링크\r\n[Link Text](Link \"title\")\r\n2. 외부 링크 그대로 사용\r\nLink\r\n3. 내부 링크\r\n[Link Text](#header-title)\r\n\r\n1. [NAVER](https://www.naver.com \"네이버로 이동합니다.\")\r\n2. https://www.naver.com\r\n3. [링크](#링크)\r\n```\r\n1. [NAVER](https://www.naver.com \"네이버로 이동합니다.\")\r\n2. https://www.naver.com\r\n3. [링크](#링크)\r\n\r\n## 이미지\r\n\r\n> `<img>` 변환\r\n\r\n```markdown\r\n![alt](이미지 주소 \"title\")\r\n\r\n1. 이미지  \r\n![바다사진](./img1.jpg \"바다\")\r\n2. 이미지 링크  \r\n[![바다사진](./img1.jpg \"바다\")](https://www.naver.com)\r\n```\r\n### 1. 이미지  \r\n![바다사진](./img1.jpg \"바다\")\r\n### 2. 이미지 링크  \r\n[![바다사진](./img1.jpg \"바다\")](https://www.naver.com)\r\n\r\n## Horizontal Rule\r\n\r\n> 각 기호를 3개 이상 입력 또는 `<hr>`\r\n\r\n```markdown\r\n***\r\n* * *\r\n---\r\n- - -\r\n___\r\n_ _ _\r\n\r\n```\r\n\r\n* * *\r\n- 마크다운(MarkDown) 사용법 총정리\r\n\r\n  <https://www.heropy.dev/p/B74sNE>"},{"id":"7f734832-50b5-5a26-8379-4f0a29e9dd53","slug":"/web-apis/","title":"Web API","categories":["Web API"],"body":"\r\n## CustomElementRegistry\r\n"},{"id":"2227c452-7eb3-5845-861a-e97d37666be8","slug":"/web/","title":"Basic","categories":["DOM","Rendering"],"body":"\r\n## DOM\r\n### Real DOM\r\n- Svelte\r\n- 브라우저가 HTML 파싱하여 생성\r\n- `.` dot 표기법으로 accessible\r\n- 변경 시 Reflow, Repaint\r\n\r\n### Shadow DOM\r\n- 각 DOM 변경사항이 서로의 요소에 적용되지 않는다.\r\n- ex\\) `<input>` `<textarea>` `<video>` `<image>`\r\n- 스타일을 완전히 분리하고 싶을 때 사용. Third-party Widgets(대화 형 위젯)\r\n\r\n### Virtual DOM\r\n- React, Vue\r\n- Virtual DOM을 Virtual DOM2 로 복제(메모리에 복제) 후 비교, 업데이트 위치 감지하여 업데이트된 요소만 변경\r\n\r\n## Rendering\r\n### SSR (Server Side Rendering)\r\n> 서버에서 완전히 렌더링 된 HTML 전달\r\n- Node.js, Multi Page Application(MPA)\r\n- 최초 로딩 속도 빠름\r\n- 페이지 이동 시 새로운 HTML 전체 다시 렌더링 (깜빡임, 로딩 속도 느림)\r\n- 위 문제 보완하기 위해 AJAX(XMLHttpRequest, fetch, Axios)로 필요한 부분(데이터)만 비동기적으로 업데이트\r\n- SEO 친화적\r\n\r\n### CSR (Client Side Rendering)\r\n> HTML, JavaScript 모두 받아온 후 JavaScript를 실행하여 동적으로 페이지 렌더링\r\n- Client 요청 &rightarrow; index.html (`<div id=\"root\"> <script scr=\"app.js\">`) 서버 응답\r\n- 최초 로딩 속도 느림\r\n- 로딩 후 실시간 데이터 처리 빠름\r\n- index.html 파일 하나로 SEO 문제\r\n\r\n### SSG (Static Site Generator)\r\n- Gatsby\r\n- 빌드 시 렌더링 마친 정적 파일들을 generate 하여 배포 &rightarrow; 정적 파일 응답 (초기 로딩 속도 빠름)\r\n\r\n### Next.js (하이브리드 프레임워크)\r\n- SSR과 CSR의 단점을 보완하기위해 만든 React 프레임워크 (SSR, CSR, SSG 모두 지원)\r\n- 자동 코드 분할(Automatic Code Splitting) : 각 페이지 로딩 시 필요한 코드만 미리 로드\r\n- Hydration (HTML을 React Application 초기화)  \r\n\t: 미리 렌더링 된 HTML에 javascript를 결합  \r\n\tHTML(dummy) &rightarrow; React Application initialized &rightarrow; Interactive App  \r\n\t- Backend에서 렌더 후 명시된(use client) componenet만 hydration\r\n\r\n## Server\r\n### Web Application Server (WAS)\r\n> 클라이언트(웹 브라우저)로부터 요청받아 동적인 콘텐츠(데이터베이스 조회) 생성하고 제공\r\n\r\n### Web Server\r\n> 클라이언트(웹 브라우저)에 하이퍼미디어(HTML, CSS, JavaScript, 이미지, API) 응답\r\n- port: 80 HTTP/ 443 HTTPS 단일 TCP 연결\r\n- FTP (파일 전송 프로토콜)\r\n"},{"id":"58f1061d-66ee-517c-9322-ca4c43842624","slug":"/Fuse-js/","title":"Gatsby 검색기능","categories":["Gatsby","Fuse.js"],"body":"\r\n## [Fuse.js](https://www.fusejs.io/)\r\n> Powerful, lightweight fuzzy-search library, with zero dependencies.  \r\n> 주어진 쿼리와 정확히 일치하는 것이 아닌 주어진 패턴과 거의 동일한 문자열을 찾는 기술\r\n\r\n## [gatsby-plugin-fusejs](https://www.gatsbyjs.com/plugins/gatsby-plugin-fusejs/)\r\n- 빌드 시 인덱스 생성(gatsby-plugin-fusejs) &rightarrow; 생성한 인덱스를 런타임(React hook)에 fuse.js 사용\r\n```js:title=gatsby-config.js\r\nmodule.exports = {\r\n\tplugins: [\r\n    {\r\n      resolve: `gatsby-plugin-fusejs`,\r\n      options: {\r\n        query: `\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tallMarkdownRemark {\r\n\t\t\t\t\t\t\tnodes {\r\n\t\t\t\t\t\t\t\tid\r\n\t\t\t\t\t\t\t\trawMarkdownBody\r\n\t\t\t\t\t\t\t\tfrontmatter {\r\n\t\t\t\t\t\t\t\t\ttitle\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t`,\r\n        keys: ['title', 'body'],\r\n        normalizer: ({ data }) =>\r\n          data.allMarkdownRemark.nodes.map(node => ({\r\n            id: node.id,\r\n            title: node.frontmatter.title,\r\n            body: node.rawMarkdownBody,\r\n          })),\r\n      },\r\n    },\r\n\t]\r\n}\r\n```\r\n\r\n```\r\n\r\n```\r\n- useStatiQuery  \r\n\t빌드 시 리액트 훅을 사용하여 GraphQL Data Layer 쿼리\r\n\r\n\r\n\r\n* * *\r\n\r\n"}]}